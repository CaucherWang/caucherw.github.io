---
layout: post
title: 分布式系统(15)
categories: Distributed-System
description: 分布式系统第十五章内容
keywords: 协调和协定
---

# 协调和协定

## 15.1 简介

- 同步系统：进程执行一条语句的运行时间，消息传送的最大延迟，时钟的漂移率，都有一个上限
- 异步系统：所有关于时间的假设都没办法达成

本章假设：

1. 进程互相独立
2. 通信是可靠的，在同步系统中，还能保证最大时延

下面讨论一下故障检测器的问题，故障检测器通常是由每个进程中的一个对象来完成的，有两种故障检测器

- 不可靠的故障检测器：对某一个进程的状态只能给出Unsuspected和suspected两种结果
- 可靠的故障检测器：对某一个进程的状态可以给出Unsuspected和Failed两种结果

大多数是不可靠的故障检测器，这种监测器的实现也比较简单，每隔一个周期T，向系统中广播一条消息，再设一个D为评估的最大的消息传输时间，那么p如果T+D时间内没收到q的广播消息，那就会反馈suspected，收到了，那就是unsuspected

下面针对T和D做一下分析：

- T和D取得太大，监测反馈太慢；取得太下，过分占用带宽。
- D可以用一定的算法动态敲定，增加准确性
- 同步系统中，D就可以确定下来了，因为消息传递有最大延迟。此时可以直接判为Failed，此时故障检测器变成可靠的了。

## 15.2 分布式互斥

考虑一组进程对共享资源的访问，要求仅以消息传递的方式同步系统内的多个进程

对互斥算法有三个要求：

1. 安全性：临界区代码某个时刻仅有一个进程可以执行
2. 活性：进入请求和离开请求最终可以被执行（无死锁，无饥饿）
3. ->顺序：如果一个请求**<u>发生在先</u>**（分布式系统中的发生在先），那么它先进临界区

对互斥算法有三个评估标准：

1. 带宽消耗：正比于每次进入enter和exit发送的消息
2. 客户时延：由于entry和exit给客户造成的时延
3. 系统吞吐率：单位时间能处理多少进临界区的进程，反比与从一个进程离开临界区到另一个进程进入临界区的时长

### 15.2.1 中央服务器算法

一个中央服务器管着令牌，进程先去申请，服务器有令牌就返回ack，没有就按到达顺序加入等待FIFO队列。得到ack之后进入临界区，执行完之后发送消息释放令牌。

<img src="2019-12-20-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(15).assets/image-20191220195558321.png" alt="image-20191220195558321" style="zoom:60%;" />

​	算法很简单，满足要求1,2，但是不满足要求3.

评估：

- 带宽消耗：3 请求+ack+释放
- 客户时延：消息往返+排队
- 同步延迟：两次消息传递  释放+ack
- 单点故障

### 15.2.2 基于环的算法

一个分布式的互斥算法，把N个进程排成一个逻辑环，令牌依次传递，要用就留下，不用往下传

<img src="2019-12-20-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(15).assets/image-20191220200351351.png" alt="image-20191220200351351" style="zoom:50%;" />

和集中式服务器算法类似，满足要求1,2，不满足要求3

评估：

- 带宽消耗：持续消耗带宽
- 客户时延：最差要等N个消息+排队，最好就0个消息；离开是稳定的一个消息
- 同步时延：最好就是1个消息，最差是N个消息，又转回来了

### 15.2.3 使用组播和逻辑时钟的算法

这个算法带有协议的性质。每个进程要进入临界区之前组播给系统中的其他进程，收到所有进程的ack时，可以进入临界区，否则就等着。对于应答方，有三种状态，released, wanted, held

- released：当即给出一个ack
- wanted: 根据时间戳判断，对方的Lamport时间戳（全序）更早，就给ack；如果晚的话，就搁置之，直到临界区代码结束
- held：搁置之，直到临界区代码结束

显然满足要求1,2，由于使用了时间戳判断，满足要求3

评估：

- 带宽消耗：进入：2*（N-1）
- 客户时延：两个消息传递+排队时间
- 同步时延：1个消息传递

### 15.2.4 Maekawa投票算法

这个投票算法比上述的组播算法进行了改进。因为其实有时候没必要征得所有人同意才能进入临界区，征得有条件的部分人同意，也可以保证互斥，进入临界区。因此，每个进程关联一个选举集，这个选举集是分布式系统进程的一个子集。这个集合有四点限制条件：

1. 进程本身必须属于自己的选举集
2. 任意两个选举集交集不为空（保证互斥的重要条件）
3. 每个选举集的大小相同，都为K
4. 每个进程隶属的选举集个数也都相同，为M

最优的情况下M=K=$\sqrt N$。

三个状态依然不变，released held wanted

- 申请进入临界区：向选举集中的K个进程发送请求，在收集到K个ack之前，不能进入临界区
- 应答方：
  - released，wanted：如果没投过票，当即回复；如果投过票了，放入一个FIFO队列，等待一个release消息，然后把请求ack掉
  - held：加入FIFO队列，自己释放了再ack掉

要求1是满足的，因为有公共选举者只能给一个候选人投票；但是不满足要求2，容易死锁，比如公共选举者有两个；要求3显然也不满足；

倒是可以改进，发送之前带个Lamport时间戳，可以满足要求2和要求3

- 带宽消耗：2*K    K
- 客户时延：2个消息传递+排队
- 同步时延：2个消息传递（release+ack)

## 15.3 选举



现在让每一个进程都有一个变量表示当前的master，当进程第一次成为参与选举的进程时，这个变量elected=⊥

类似地，我们对选举算法有一定的要求：

- 安全性：参与的进程pi有$elected_i$ =⊥或$elected_i$ = P（P是在运行结束时具有最大标识符的非崩溃进程）

  - 通俗的讲：最终只能选出一个Master来

- 活性：所有进程pi都参加并且最终置$elected_i$ ≠⊥或进程pi崩溃

  - 通俗地讲：全员都参与选举，并且最后能得到结果

衡量指标：

- 带宽消耗：发送的消息总数
- 回转时间：从启动算法到终止算法串行发送的消息总数



### 15.3.1 基于环的选举算法

还是将进程拓扑排成环，所有进程开始都是非参与者，任意一个进程可以发起选举，把自己置位参与者，发送<elect, id>

对于不主动发起的进程：

- 参与者：

  - 如果收到的标识符比自己大，就转发<elect, id_msg>
  - 如果收到的标识符比自己小，拒绝转发
  - 如果收到的标识符和自己一样，那就是转了一圈转回来了，自己当选，设置变量，然后转发<elected, id>，最后设置自己为非参与者

- 非参与者：

  - 如果收到的标识符比自己大，就转发<elect, id_msg>，把自己置位参与者
  - 如果收到的标识符比自己小，就转发<elect, id>，把自己置位参与者

  

<img src="2019-12-20-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(15).assets/image-20191221125312754.png" alt="image-20191221125312754" style="zoom:50%;" />

算法评估：安全性，也就是只有一个Master，肯定是满足的，因为传回来elect消息时已经比过一圈了，有比自己大的它不会传自己。活性：因为是环算法，肯定全员参与，最后又传了一圈elected，所以都有结果。二哥条件都能满足

衡量指标：

- 带宽消耗：最好情况下：发起者当选 2N  最差情况下，最后一个人当选 3N-1
- 回转时间：和带宽消耗一样的，消息都是串行发送的
- 容错性：一点都不容错，丢包，宕机，算法崩溃。

### 15.3.2 霸道算法

这个算法有一些前提条件：

- 同步系统（有超时验错）
- 消息传递可靠
- 有先验条件：进程知道系统内其他进程的标识符，可以直接和他们通信

算法流程如下：

<img src="2019-12-20-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(15).assets/image-20191221134447645.png" alt="image-20191221134447645" style="zoom:40%;" />

算法评估：安全性方面，在消息传递可靠的情况下，肯定只有标识符最大的能当选，安全性可以保证；活性方面，所有进程最后都能收到结果，可以保证两个条件

- 带宽消耗： 最好 次大者发起选举 N-1个协调者消息  最差  最小者发起选举 N^2级别的
- 回转时间：最好  1个消息传递  最差  N级别的  次大者先回应所有人消息  然后发布协调者消息



## 15.4 组通信中的协调和协定

**组播面临的挑战**

- 效率
  - 带宽使用
  - 总传输时间
- 传递保证
  - 可靠性
  - 顺序

- 进程组管理
  - 进程可任意加入或退出进程组

一些定义和模型

- 开放组：组外成员可以向组内组播消息
- 封闭组：组外成员不能向组内组播消息
- multicast(g,m)：m中包含发送者消息
- deliver(m)：某进程将消息m传递给应用层

### 15.4.1 基本组播

基本组播保证了可靠的组播通信，称为B-multicast

实际上就是多个一对一的TCP拼起来的，相应的deliver称为B-deliver

很容易在大组中产生确认爆炸的现象，有不稳定的因素在

### 15.4.2 可靠组播

可靠组播的一个重要条件就是一个活性要求，也可以称为原子性，就是全0或全1，组内进程要么都收到，要么都别收到这个问题。B-multicast就满足不了这个条件，如果sender发出一部分之后挂了，已发出进程一样deliver就违背了原子性。可靠组播的原语称为R-multicast  R-deliver

下面给出可靠组播的三个条件：

1. 完整性：一个正确的进程p只会deliver消息m一次
2. 有效性：一个正确的进程p组播消息m，它最终会deliver这个m
3. 协定：一个正确的进程p组播消息m，它所在的组中其他的正确的进程最终都会deliver m
   - 统一协定：一个更强的协定条件，即进程组播消息m，无论进程时正确的还是错误的，组中所有其它正确的进程都会deliver m



#### 15.4.2.1 基于B-multicast实现可靠组播

​	算法针对于封闭组，思想很简单，组播仍然用B-multicast作为R-multicast，但是，到了R-deliver的时候，如果发现了重复，就忽视之；第一次来的话，如果自己不是sender，就再B-multicast把消息传递出去，然后再B-deliver。

​	如果一个进程R-deliver了，说明它一定完整的B-multicast过。如果他没R-deliver，第一种情况是根本没收到过，第二种情况是它自己B-multicast时宕机了。第一种情况下，它如果没收到，由于B-multicast的可靠性，那就是根本没人B-multicast过，满足协定。第二种情况下，它自己B-multicast时宕机了，它就不是一个正确的进程，收不到R-deliver，也不违反协定。

- 算法评估：每个正确的进程最终都会收到同样的消息g次

#### 15.4.2.2 用IP组播实现可靠组播

由于IP组播是基于UDP进行消息传递的，这意味着消息传递是不可靠的。基于此，为了实现可靠组播，加入了序号机制。组播组的每一个成员维护一个向量，用于维护在这个组中收到的消息的序号，对于其他每个进程，这个向量中的相应元素表示最近从该进程收到的消息序号；对于自己这个进程，相应的元素表示自己组播消息的序号，即下次组播消息的编号。

对于发送者：

- 每次发送的时候把自己的那个向量都捎带着一起发出去，一方面为了确认之前的sender，另一方面为了协调其他组播成员

对于接收者：

- 如果：
- 1. 收到的序号正好比自己对于sender进程的确认号大1，并且收到的确认号也都不比自己大，当场R-deliver掉
  2. 收到的序号不大于自己对于sender进程的确认号，那是重复消息，忽视之
  3. 收到的序号比自己对于sender进程的确认号大1以上，那是中间掉了好几个包，先把收到的放入一个保留队列缓存起来，或者收到的确认号有比自己相应的确认号大的，发送NAK申请之前丢的包

算法评估：完整性可以通过向量确认号来保证不会重复deliver，IP组播保证不会错传。有效性要看IP组播会不会自己传自己，最后协定，如果所有进程都在无限组播，并且无限缓存历史消息，才可以满足。

### 15.4.3 有序组播

在可靠组播的基础上，进一步可以考虑实现有序组播。有序有三种含义：

- FIFO序：如果一个进程先multicast m，后multicast n，那么所有正确的进程deliver n之前必须先deliver m了
- 因果序：如果multicast m比multicast n发生在先， 那么所有正确的进程deliver n之前必须先deliver m了
- 全序：所有进程deliver的顺序必须一样，而不管实际发生的顺序到底是啥样的

可以看出因果序严格于FIFO序的，然而全序和因果序没有什么必然联系。因此也可以混合，FIFO-全序，因果-全序达到了最严格的级别

有序还可以和可靠进行联系，其中，可靠全序组播被称为**原子组播**

#### 15.4.3.1 实现FIFO序

思想非常简单，每个进程依然维护一个向量，和基于IP组播的可靠组播方式类似，在比对接收到了连续的消息之后再递送上层即可。

#### 15.4.3.2 实现全序

##### 15.4.3.2.1 顺序者的全排序算法

就是在组播组内加一个进程，称为顺序者，顺序者本地维护一个全局顺序号，每个组播组成员也维护一个本地的全局顺序号，当然这个本地的全局顺序号很可能是延迟的，较小的。

​	每次multicast的时候对消息加一个全局唯一的ID，顺序者收到之后顺序号递增，将<ID,全局顺序号>组播出去，其它组播组成员收到这个消息之后，等到自己的本地的全局顺序号到达那个值的时候，将其删除保留队列然后递送。

​	算法正确性没有问题，只不过随着组播组增大，顺序者进程成了性能瓶颈。组播时延是2个消息传递的时间

##### 15.4.3.2.2 ISIS全排序算法

去除了集中式的顺序者进程，算法是分布式P2P的

算法如下：

- 发送方multicast一个消息m，加一个全局唯一的标识符i
- 接收方根据本地接触过的最大协议序号和本地提议过的最大序号的较大值+1，给sender一个消息，即该接收方的提议序号，此时根据协议序号把消息m扔进保留队列
- 发送方接收到所有接收方给出的提议序号，选择一个最大值，作为消息m的协议序号，发送给所有接收方
- 接收方收到协议序号之后，把保留队列中的m改成协议序号，如果其正好在队首，那就移到deliver队列去

算法评估：延迟更大了，有3个消息传递时间，但是破除了性能瓶颈；另外，这是接触到的第一个开放组播的算法。

#### 15.4.3.3 实现因果序

谈到因果序，必然要让每个进程维护一个向量时间戳。组播的时候带着时间戳组播掉。

对于接收者，先把收到的消息放入保留队列里。直到这个的消息时间戳：

1. 对于发送者的值正好等于本地时间戳+1
2. 对于非发送者的值均不大于本地时间戳

此时说明满足一切依赖关系，可以deliver这个消息

很容易证明这个算法是正确的。另外，如果用顺序者的全序实现方案，根据因果序的时间戳递送消息，就可以得到因果-全序的方案。

#### 15.4.3.4 重叠组

有的时候组之间不是完全割裂的，而是有很大重叠的，也就是说对于不同组的组播，有时也是要求顺序组播的。

- 全局FIFO序：进程向g组播m，然后向g'组播m'，那么对于g∩g'的进程，递送要满足先m再m'
- 全局因果序：类似上面，如果两次组播在任何组播消息链上都满足因果序，递送也有同样的顺序
- 进程对的全排序：在公共进程中，所有进程的deliver 的顺序都是全局一样的
- 全局的全排序：进程对的全排序加上无环

## 15.5 共识和相关问题

- 协定：在一个分布式系统中，一个或多个进程提议了一个值应当是什么后，系统的所有进程对这个值达成一致的意见。

### 15.5.1 系统模型和问题定义

- 共识问题：N个进程开始处于未决的状态，并且提议一个集合D（N个元素）中的一个值，然后进程间相互通信交换值。最后每个进程设置一个决定变量的值，然后进入决定变量不再改变。

  共识算法的要求：

  - 终止性：每个正确进程最后将设置它的决定变量
  - 协定性：所有正确进程的决定值都是相同的
  - 完整性：如果正确的进程都提议同一个值，那么决定值也同是这一个值。

- 拜占庭将军问题：3个或者更多将军协商共同进攻还是撤退，谁都有可能叛变，司令将军发出一个提议，其他中尉将军互相交换信息，最后各自得到一个决议。与共识问题不同的是，这里只有司令将军发出提议，而不是所有人都发出提议。

  拜占庭将军算法要求：

  - 终止性：每个正确进程最后都有一个决定变量
  - 协定性：所有的正确进程决定变量都相同
  - 完整性：如果司令是正确的，那么所有正确进城的决定变量都和司令一致

- 交互一致性：与共识问题唯一一点差别就是决定变量是一个向量，向量中的每一个分量与一个进程的值相对应。

  交互一致性要求：

  - 终止性：每个正确进程最后都有一个决定向量
  - 协定性：所有的正确进程决定向量都相同
  - 完整性：如果正确的进程提议了一个值，那么决定向量关于该进程的分量就是这个值。

- 共识问题、拜占庭将军问题、交互一致性问题有着紧密的联系，算法结果稍作转化就可以变成另一个算法的结果。

### 15.5.2 同步系统中的共识问题

假设N个进程中最多有f个进程会出现崩溃故障。

每一轮正确的进程广播自己的新收到的提议消息，其他进程收到之后加入到自己的已收到的集合中，留着下一轮广播。如果不出故障，一轮之后，所有进程的集合都是一致的。但是如果一个出了故障，就有一个不一致的元素，再次组播增量，可以在第二轮之后保证所有进程的集合都是一致的。

以此类推，每增加一轮组播，就可以屏蔽一个故障。f+1轮的信息收集意味着可以容忍f个进程故障。

### 15.5.3 同步系统中的拜占庭将军问题

N>=3f+1，才能保证一致性和完整性

### 15.5.4 异步系统的不可能性

异步系统总是不可能达到共识的，但是三个技术可以绕过不可能性：

1. 故障屏蔽：
2. 使用故障检测器达到共识
3. 使用随机化达到共识

