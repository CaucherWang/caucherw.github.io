---
layout: post
title: 分布式系统(3)
categories: 分布式系统
description: 分布式系统第四章内容
keywords: 分布式系统
---

# 3. 进程间通信

## 3.1 简介

两种消息传递方式

- UDP：不是很可靠，失序，重发，需要APP来处理，没有确认和重发
- TCP：双向流，生产者-消费者

### 3.2.1 进程间通信的特征

- 同步和异步通信：
  - 同步：发送进程和接收进程每个消息完全同步，没有收到返回就一直等待,send,receive全阻塞；效率低
  - 异步：send非阻塞，发到缓冲区就不管了；receive都行，一般是阻塞的，非阻塞的可能要用轮询或者中断来保障；效率高；并发处理还要再处理、
- 消息的目的地：<互联网地址，本地端口>
  - 假设每台计算机一个ip地址，每个端口号一个进程
  - 一个端口号只能有一个进程来掌管，但是一个进程可以拥有多个端口号
  - 一个端口号只能有一个进程接受，但可以很多人发送
  - 组播：很多人在监听，谁收到谁算
  - 名字服务DNS，提供位置透明，不过可重定位，不可迁移，就是运行时不能换子网
- 可靠性
  - 有效性：如果一个点对点消息服务在丢失了“合理”数量的数据包后，仍能保证发送消息，那么该服务就称为可靠的；
  
    相反，只丢失一个数据包，消息就不能保证发送，那么这个点对点消息服务仍是不可靠的
  
  - 完整性：不坏，不重
- 保序：TCP没问题，UDP就不行
- 一般来说TCP层就OK，再快就IP；TCP只管送数据，送什么还要自己定，是FTP还是自己搞
- Socket：自动实现TCP/UDP IP协议，其实Socket也会跨层，直接用IP的接口
  - SOCK_STREAM：对应TCP，双向连接
  - SOCK_DGRAM：对应UDP，无连接服务，块
  - SOCK_ROW：可以直接IP访问
  - Winsock  BSDsock

### 3.2.3 UDP数据报通信

- 消息大小：固定大小，用于接收消息的字节数组，太大的消息会截断
- 任意接收：不指定消息来源
- 遗漏故障肯定会有，开销肯定是很低

### 3.2.4 TCP流通信

- 收发内容一致
- 线程：server端接受连接时，会新建一个线程的
- 仅当网络拥塞时会出现遗漏故障

## 3.3 外部数据的表示和编码

 存储在运行的程序中的信息都表示成数据结构，而消息中的信息由字节序列组成

 不论使用何种通信形式，数据结构在传输时都必须转换成字节序列，到达目的地后再重构

 下列方法可以用于两台计算机交换数据值：

- 值在传送前先转换成一致的外部数据，然后在接收端转换成本地格式

- 值按照发送端格式传送，同时传送所使用格式的标志，接收方进行转换

为了支持RMI或RPC，任何能作为参数或作为结果返回的数据类型必须被转换为字节序列

- 表示数据结构和简单值的一致标准称为**外部数据表示**

- 编码(marshalling)是将多个数据项组成适合消息传送的格式的过程

- 解码(unmarshalling)是在消息到达后分解消息，在目的地生成相等的数据项的过程

- 三种外部数据表示和编码方法
  - CORBA
  - Java对象序列化
  - XML（跨语言，现在一般用json来传）

### 3.3.1 COBRA公共数据表示

- 15种简单类型
- 1套组合类型
- 基础类型：
  - 定义了大端or小端
  - 按顺序传送
  - 接收端可能要翻译，因为数据表示顺序不同
- 结构化类型
  - 类似struct，没有动态对齐机制
  - 4个字节一个格，多了进，不够的补齐

### 3.3.2 Java对象序列化

在Java中，serialization指的是将一个对象或者一组关联的对象打平成适合于磁盘存储或消息传送的串行格式

 解序列化是指从串行格式中恢复对象或一组对象的状态

- 假设：解序列化进程事先不知道序列化格式中对象的类型

- 需要将关于每个对象类的一些信息包含在序列化格式中，使得解序列化时能装载恰当的类

 类信息由类名和版本号组成，当类有大的改动时要修改版本号

 Java对象可以包含对其他对象的引用，当对象序列化时，它所引用的所有对象也随它一起序列化，以确保对象在目的地重构时它引用的对象也能恢复。

- 引用对象序列化成句柄----在这种情况下，句柄（handle）是在序列化格式内对一个对象的引用。

  - 序列化过程必须确保对象引用和句柄之间是一一对应的

  - 也必须确保每个对象只能写（写入字节序列）一次-----在对象第二次出项及之后再出现时，写入句柄而不是对象

<img src="2019-09-25-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(3).assets/image-20191223235443850.png" alt="image-20191223235443850" style="zoom:53%;" />

- 反射：Java通过对象查询类信息的能力

  - 反射实现了根据类名创建类的能力，以及为给定的类创建具有给定参数类型的构造函数

  - 反射使得以完全通用的方式进行序列化和反序列化成为可能（无需为每种数据结构创建序列化函数）
  - Java对象序列化使用反射找到要序列化的对象的类名，以及该类的实例变量的名字、类型和值

  - 对解序列化而言，序列化格式中的类名用于创建类。然后用类名创建一个新的构造函数，它具有与指定在序列化格式中的类型相应的参数类型。最后，新的构造函数用于创建新的对象，其实例变量的值可以从序列化格式中读取。

### 3.3.3 XML

XML与HTML不同的是，标记可以自己随便搞

 XML文档是文本形式存储的

- 使得XML可以独立于某个平台

- 使用文本而不是二进制会使得消息内容变大

### 3.3.4 远程对象引用

 远程对象引用：是远程对象的标识符，在整个分布式系统中有效。

客户端调用远程对象中的一个方法时，就会向存放远程对象的服务器进程发送一个调用消息。这个消息需要指定哪一个对象具有要调用的方法。 远程对象引用在调用消息中传递，以指定调用哪一个对象。

<img src="2019-09-25-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(3).assets/image-20191224103515440.png" alt="image-20191224103515440" style="zoom:60%;" />

拼接计算机的互联网地址、创建远程对象应用的进程的端口号、创建时间和本地对象编号来构成远程对象引用。每次进程创建一个对象，本地对象编号就增加1

## 3.4 组播通信

 组播操作（multicast operation）

- 将单个消息从一个进程发送到一组进程的每个成员的操作

- 组的成员对发送方通常是透明的

- 分布式系统用组播：

  - 基于复制服务的容错

    一个复制服务由一组服务组成，客户请求被组播到所有成员，每个成员执行相同操作
  
  - 在自发网络中发现服务
  
    客户和服务器使用组播消息来找到可用的发现服务
  
  - 通过复制的数据获得更好的性能
  
    例如：数据副本放在用户计算机上，每次数据改变，新值就组播到副本数据各个进程中
  
  - 事件通知的传播
  
    在发生某些事件时通知相关进程
- IP组播
  - ipv4前四位1110的地址（224.0.0.0～239.255.255.255），加上一个固定的端口号，往这个套接字地址发消息，就会对组播组的每个成员转发一个副本
  
  - 只有UDP传输可以组播。组播成员是动态的，计算机可以在任何时间加入或离开，计算机也可以加入任意数量的组。可以无需成为组成员就像一个组发送数据报。
  
  - 组播路由器（multicast router）：IP数据包既能从局域网上组播，也能在互联网上组播。
  
    - 本地组播使用了局域网的组播能力
  
    - 互联网上的组播利用了组播路由器，将单个数据发送到其他成员所在的网络的路由器上，再通过路由器组播到本地成员
  
    - 为了限制组播数据报传播的距离，发送方可以指定允许通过的路由器数量（存活时间TTL）TTL=1，本地局域网
  
  - 这些组播地址也各有划分，有一部分是本地网络，有一部分是互联网络，还有的服务于作用域机制。
  
  - 有一部分组播地址是暂时的，有部分是永久的。暂时的使用前创建，没有进程了就消失。
  
  - 组播地址分配服务器可以提供一个互联网上的组播地址，利用的是**<u>组播地址分配架构</u>**，给定TTL，给定作用域，可以保证唯一组播地址
  
  - 故障模型和UDP一样  都有遗漏故障
  
  - 在JAVA API里，本地接受进程端口确定了，也只能连接上该端口的组播套接字。并且只能在同一组才能向组内发消息，正常不是这样。

### 3.5.1 覆盖网络

节点和虚拟链接组成的虚拟网络，位于一个底层网络之上

- Skype：超级节点的缓存与索引结构。主UDP，辅TCP

- 覆盖网络的好处

  - 不改变底层网络就能定义新的网络服务

  - 鼓励对网络服务进行实验和对服务进行面向特定应用的定制

  - 能定义多个覆盖网，它们能同时存在，从而形成更开放和扩展的网络体系结构