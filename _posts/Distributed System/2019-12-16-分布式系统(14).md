---
layout: post
title: 分布式系统(14)
categories: Distributed-System
description: 分布式系统第十四章内容
keywords: 时间和全局状态，时钟协调，全局状态，谓词判断，分布式调试
---


# 时间和全局状态

## 14.1 简介

没有绝对的全局时间，任何硬件时间都有一定的时钟漂移率。国际最准确的是原子时间也有漂移率，权威外部时间UTC漂移率则更大。

## 14.2 时钟、时间和进程状态

给出一些定义

- 分布式系统$P$：是进程$p_i$的集合，每个进程单线程单处理器工作，能且只能通过网络通信
- 进程状态$s_i$：包括进程的变量和本地OS环境中的数据，比如文件等
- 动作$e_i$：通信或状态转换
- 进程的历史$history(p_i)$：一系列全序动作的集合
- 分布式系统的全局历史$H$:就是进程历史的并集
- 进程的硬件时间值$H_i(t)$：从硬件里读的时间
- 进程的软件时钟值$C_i(t)$：从软件里能读到的时间，$C_i(t)=\alpha H_i(t)+\beta$
- 时钟漂移律$\rho$：单位时间和完美时钟差的时间

## 14.3 同步物理时钟

设实际时间（完美时钟的时间）为$t$，UTC时间源为$S$

- N个进程在范围D内外部同步：任意的i，$|S(t)-C_i(t)|<D$

- N个进程在范围D内内部同步：任意的i,j，$|C_i(t)-C_j(t)|<D$

- 显然，N个进程在范围D外部同步，必有在范围2D内，内部同步

- **时钟正确性**：硬件时钟的误差是有界的，即硬件时钟的漂移律已知或有上界
  $$
  (1-\rho)|t-t'|<|H_i(t)-H_i(t')|<(1+\rho)|t-t'|
  $$

- 显然，时钟正确性可以保证硬件时钟单调性

- 单调性：指软件时钟单调性，实际时间往前了，软件时间必须也往前

- 故障：不满足**时钟正确性**就是时钟故障

  - 崩溃故障：时钟不走了
  - 随机故障：其他问题都是随机故障

### 14.3.1 同步系统中的同步

- 同步系统：给定
  - 时钟漂移律$\rho$的范围
  - 最大消息传输延迟$max$，最小消息传输延迟$min$
  - 进程每一步的执行时间

现在，不考虑网络带宽竞争，不考虑节点内进程竞争。

进程A给进程B发一次消息，就能同步时钟（内部同步），设置B的时间为$t+t_{trans}$即可，但是传输时间在min和max之间浮动，不能准确得知，权衡之下，只能设置进程B的时间为$t+(max-min)/2$，简写为$t+u/2$，这样可以保证两个不同进程之间只有$u/2$的内部偏移率。

一个论文里推广了这个结论，得出N个系统同步时钟时，最多只有$u(1-1/N)$的时钟便宜范围

### 14.3.2 同步时钟的Cristian方法

原理十分简单，一个时钟服务器连接UTC，设为S，拥有权威时间。现一进程p想要外部同步，发送请求然后接收，记录RTT=$T_{round}$，然后将时间设为$t+T_{round}/2$，即为同步。

误差分析：

设最小消息传输延迟可估量为$min$，忽略服务器处理时间

<img src="2019-12-16-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(14).assets/image-20191217000049117.png" alt="image-20191217000049117" style="zoom:33%;" />

- 如果消息在$min$时刻到达，那么消息返回Client时，Server的时间是$t+T_{round}-min$
- 如果消息在$T_{round}-min$时刻到达，那么消息返回Client时，Server的时间是$t+min$

由于我们设置时间为$t+T_{round}/2$，所以误差最大就是$T_{round}/2-min$

- 结论1：往返时间越小，误差也就越小；因此可以多测几次选个最小值
- 结论2：对时钟同步要求的精度不能在$T_{round}$级别的，否则失效。

### 14.3.3 Berkeley算法

与Cristian采用了相反的算法，由服务器向多个客户端轮询，收集到客户端的时间之后去除掉那些差的提多的时间，剩下的取个平均值作为一个标准时间，然后对各个客户端返回消息，返回消息中带有需要调整时间的偏移量。

### 14.3.4 网络时间协议

即NTP( Network Time Protocol)，

## 14.4 逻辑时间和逻辑时钟

由于物理时间的不可能性，我们只能给分布式系统中的事件按逻辑排序。

Lamport提出一种发生在先关系，也称为因果序，有两点要求：

1. 对于同一进程内先后发生的事件，在因果序必须也维持相同的顺序；
2. 对于消息传递的事件，消息接收必须在消息发送的后面

可以轻易推论出，因果序有传递性，并且不是唯一的，这意味着某一种绝对的时间顺序，可以对等多种不同的因果序，这是由于并发事件的原因。两个事件按照发生在先关系无法分出先后的，就定义为并发事件。我们不关心这样的事件的顺序。

### 14.4.2 Lamport时间戳

放弃物理时钟，每个进程使用计数器充当逻辑时钟，称为Lamport时间戳，增长规则如下：

- 每个进程从0开始，发生事件之前，时间戳自增；
- 发送消息时，在消息中附加本地时间戳；收到消息的，本地时间戳取远程时间戳和本地时间戳的较大值，然后接收消息时本地时间戳再自增

显然，事件发生在先，Lamport时间戳也会较小；但反之肯定不成立，因为很有可能是并发的。

为了给所有的时间戳排个全序，就构成<T,p>二元组，没有什么物理意义，但是T相同之时能随机选一个更小的就是了。

### 14.4.3 向量时间戳

Lamport时间戳有一个缺点就是缺少事件发生在前的充要条件。向量时间戳解决了这个问题。

每个进程单独维护一个向量，向量中的每个元素代表一个进程，代表自己进程的那个值就是自己的Lamport时间戳；某状态下的其它进程对应元素的时间戳代表该状态的存在至少依赖于其他进程到了什么状态。

除了进程中事件发生更新时间戳外，消息传递时携带时间戳，并且在到达时会与远程的时间戳进行合并，取较大值。

向量时间戳比较小代表每个元素都比较小。在这种情况下，事件发生在前和向量时间戳达成了充要条件。

向量时间戳也可以用来确定并发事件，只要两个事件的时间戳是比较不了大小关系的，两个事件就是并发的。

## 14.5 全局状态

### 14.5.1 全局状态和一致割集

### 14.5.2 Chandy-Lamport 快照算法

## 14.6 分布式调试

分布式调试一般设计成集中式的，在一个集中式的进程监控分布式系统的状态。

调试的目的，就是能随时监控系统的执行，而并非一个快照。

对于一个谓词$\phi$，我们给出两个定义

- 可能的$\phi$：存在一个一致的全局状态S，H的一个线性化走向经历了这个状态S，而且此时$\phi(s)=true$
- 明确的$\phi$：对于H的任意一个线性化走向L，都存在一个L经历的全局状态S，使得$\phi(s)=true$

举个例子，如果Chandy Lamport发现了一个系统快照，使得$\phi(s)=true$，那么就是说可能的$\phi$是成立的。可能的$\phi$是成立的，不代表在实际执行过程中就一定有某个状态使得$\phi(s)=true$ ，但是可以说有可能是这样的。

### 14.6.1 收集状态

​	系统中的每个进程向monitor进程发送状态消息，monitor进程为每一个进程开一个队列，专门用来收集消息。

​	注意进程发送给monitor进程发送状态消息，可能会使得进程正常执行变慢，但是基本的顺序和状态并没有收到干扰。

​	即使如此，也可以有一些策略进一步减少消息流量：

- 如果只想关注特定的$\phi$，那么只发送和$\phi$相关的状态变量即可
- 另外，只有在谓词发生变化时发送状态消息是很有意义的，谓词没变化，可以不发送相关状态信息

### 14.6.2 观察一致的全局状态

​	为了能在调试过程中计算$\phi$，必须确认收集到了一致的全局状态，然后做出谓词判断。

​	基于此，进程在发送状态信息的时候，必须一起发送此时的矢量时间戳，这个矢量时间戳有两个作用

- 第一，由于通信可能失序到达，矢量时间戳有关本进程的时间戳实际上就是消息发送的一个排序
- 第二，进程发送的矢量时间戳的有关其他进程的时间戳，实际上表明了对其他进程状态的最小依赖，对于一个一致的全局状态，其他进程状态的时间戳不得小于这个值，这就可以为找到一个一致的全局状态做出判断。

对于第二个条件的作用，可以汇总成一个CGS条件，用于确定一个一致的全局状态：
$$
V(s_i)[i]>=V(s_j)[i]  (i,j=1, 2, …, N)
$$
​	基于此，如果我们给出一个层次化网格，就能给出一个分布式系统的所有线性化走向。每一个节点都是一个一致的全局状态，自上至下就是一个线性化走向。每一个层次的迭代都代表了某一个进程的一个状态改变，或称为事件发生。

​	我们换句话说，就是每一个状态的下标代表的割集是一个一致割集，不能违背发生在先关系，那它就可以进入这个网格，而不管它是否一定出现。

​	进一步，monitor进程是可以绘制出这样一个网格图的。基于此，他就可以判断出来：

- 可能的$\phi$：只要DFS扫一遍图，看有没有一个时刻，$\phi(s)=true$，找到了即可成立
- 明确的$\phi$：需要找到一个状态集，每个路径都是必须经过这些状态中的一个的时候，如果这个状态集中的所有$\phi$都有$\phi(s)=true$，即可成立

<img src="2019-12-16-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(14).assets/image-20191220154830625.png" alt="image-20191220154830625" style="zoom:50%;" />

### 14.6.3 判定可能的$\phi$

​	下面我们具体说说求解可能的$\phi$

​	刚才我们讲到过，求解可能的$\phi$只需要遍历全局状态网格中的每一个一致状态，只要发现一个一致状态是满足$\phi(s)=true$，即可成立。在实际操作中，可以用下面的算法进行查找。

​	基本思想：分层迭代，查找每一层的每一个一致状态S

- 1. 初始化状态集为每个进程的初始化状态
- 2. 如果状态集中的每一个状态都不能满足$\phi(s)=true$，进入循环，否则返回true
  3. 循环体：层次+1，从现有状态集，在整个系统的历史中，找下一个一步可达的一致状态集，然后更新现有状态集。
- 至于如何在系统历史中从现有状态集找下一个一步可达的一致状态集，分以下几步走：
  1. 新的全局状态必须只在旧的全局状态中的一个进程状态中增长一个时间戳
  2. 新的全局状态对其他进程状态的依赖，必须在旧的其他进程状态就已经得以满足

### 14.6.4 判定明确的$\phi$

和上一个节描述的算法类似，依然是分层迭代，只不过对于那些已经可以使得$\phi(s)=true$的全局状态为根节点的子树，就没必要再去判断了，只对那些false节点向下延伸的子树作出迭代判断即可。

### 14.6.5 在同步系统中判定可能的φ和明确的φ

同步系统对一致的全局状态有着更苛刻的要求，不仅逻辑上要求发生在先，而且要求物理上，他们也必须有可能在同一实际时间发生。对于逻辑上的一致全局状态，要检查每两个进程此时的状态能否在物理上同时发生，因此发送状态消息时，要额外发送物理时间戳，用于进行物理上的校验。