---
layout: post
title: 分布式系统(16)
categories: Distributed-System
description: 分布式系统第十六章内容
keywords: 事物，并发控制，锁，时间戳，乐观并发
---

# 协调和协定

# 事物和并发控制

### 16.4.2 在加锁机制中增加并发度

#### 16.4.2.1 双版本加锁

规则如下图，可以看到读写的吞吐量都迅速上升，互斥被推迟到了commit阶段。然而commit阶段非常容易死锁和超时，因为读事物的进行会一直推迟commit的发生。读是已提交读，不会脏读。脏写就根本不会发生。其实是引入了commit锁这么一种新锁。

<img src="2019-12-20-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(16).assets/image-20191221224858032.png" alt="image-20191221224858032" style="zoom:40%;" />

#### 16.4.2.2 层次锁

在锁的粒度之间找出一种上下级的包含关系。上级设置锁意味着在所有下级设置相同的锁。下级设置锁时，首先要看看上层能否允许自己设置相应类型的锁，然后在上层设置试图锁。其实引入了试图读锁和试图写锁两种新锁。

### 16.5 乐观并发控制

锁机制有几个缺点：

- 锁维护开销，而且限制了并发量
- 死锁的问题
- 连锁放弃

乐观并发控制分三个阶段

- 工作阶段
　- 每个事务拥有所修改对象的临时版本
    - 每个事务维护访问对象的两个集合：读集合和写集合
- 验证阶段
    - 在收到closeTransaction请求，判断是否与其它事务存在冲突。
- 更新阶段
    - 提交通过验证的事务

### 事物的提交验证

- 向后验证

对于事物T，从T开始执行时的最大的尚未提交的事件开始，到T进入验证阶段分配的最大事务号为止，验证他们的写集合T的读集是否重合，重合就回滚。