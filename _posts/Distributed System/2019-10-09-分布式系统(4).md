---
layout: post
title: RPC & RMI
categories: 分布式系统
description: 远程过程调用，远程方法调用，以及基本的请求应答协议
keywords: 分布式系统, RPC, RMI, RR protocal
---

# 4.远程调用

## 4.2 请求应答协议

一个弱于TCP，强于UDP的应用层通信协议。

- C/S模式

- 同步通信模式
  
  - 发送方阻塞，直到收到服务方确认
  
- TCP流是主要的形式

- 三个通信原语
  - doOperation
  - getRequest
  - sendReply
  
- 消息基本结构：外壳的作用就是因为存在故障问题，丢包，失序等
  - messageType：request or reply
  - requestId：主要为了故障处理而生，一个整数序列+发送者套接字地址
  - remoteReference:远程那个函数
  - operationId: 具体操作
  - 参数列表：字节流
  
- 超时：doOperation，超时就重发，此时消息ID就有用了，可以避免重复

- 面对重复请求：

  - 没有发过应答包：滤掉多余请求，只执行回应一个
  - 已经发过应答包：
    - 幂等操作：不干预即可
    - 非幂等操作：拒绝掉

- 历史：包含最近一次已发送消息记录的结构，这样重传就不需要重复计算，只需要再重传reply
  
  - 只需最近一次是因为同步协议，客户发出k+1个请求意味着第k个请求已经收到
  
  - 当然历史太大的时候，计算和存储的开销都会变大
  
- 交互协议的类型
  - 请求：UDP
  - 请求-应答（通选）
  - 请求-应答-确认应答（类似TCP三次握手协议，更好的处理history）
  
- TCP流的使用（通选）
  - UDP数据包有长度限制，不利于RPC或RMI的透明化
  - 避免实现多包协议，不想让数据拆分成包，以传输任意长度的参数或结果，TCP是数据流
  - 可靠是优良的性质，使得通信简化，很多机制可以缺省
  
- 也可以基于UDP进行改良，如果不需要TCP所提供的所有服务的话

- 例子：HTTP：请求-应答协议
  - 内容协商：Client request里面包含一些它们可以接受的数据信息
  - 认证：质询
  - 持久连接
  - HTTP方法：
    - put,delete是幂等操作，但是post操作就未必

## 4.3 RPC

### 4.3.1

- 接口编程
  - 分布式系统的接口
    - 运行在不同的进程里，和传统OS不同，传统OS有进程地址封锁，不同进程访问不到
    - 传递消息不能用引用参数，只能用值参数，然后将参数序列化
  - 接口定义语言IDL：为多语言的应用RPC提供了统一的接口定义
    - Sun XDR
    - CORBA IDL
    - WSDL
- RPC调用语义
  - 重发
  
  - 滤重
  
  - 重传结果
  
  - 或许调用语义：R，远程方法可能执行一次，也可能根本没执行，客户什么也不知道。除了重复以外，所有故障都可能出现。
  
  - 至少一次调用语义：Client收到结果或异常。如果收到结果，那么该方法至少被调用一次了。不会丢包，但是会有重复。也不滤重，重新执行并且传结果。【幂等操作】
  
  - 至多一次：Client收到结果或异常，如果收到结果，方法执行且只执行一次。重传但不重新执行，只发回复。
  
  - 透明性：本地过程和远程过程的差异应该体现在接口上
  
    - 以SUN RPC为例，用户想要调用远程过程，有以下步骤
  
      - 创建一个句柄，指明服务器名字，程序标识符及版本
      - 根据XDR接口（C语言），构造结构化参数及返回值
      - 直接调用远程过程，第二个参数为客户端句柄
  
      <img src="C:\Users\64451\Pictures\md_images\1571219377530.png" alt="1571219377530" style="zoom:50%;" />
  
    - 服务端的过程几乎和C语言无差异，只是要遵守一些函数命名、返回值、参数的规范协议而已
  
      <img src="C:\Users\64451\Pictures\md_images\1571229993644.png" alt="1571229993644" style="zoom:50%;" />
  
      - 剩下的通信过程等底层过程，全部由IDL的编译器来自动生成，对高层程序员完全屏蔽掉

### 4.3.2 RPC的实现

<img src="C:\Users\64451\Pictures\md_images\1571218844461.png" alt="1571218844461" style="zoom:67%;" />

​	上面提到了，底层实现都是由一个特殊的编译器自动实现的，必须包括以下几个部分

- client program*：用户的app，正如上面所展示的，要求调用远程过程，并提供结构化参数
- client stub：根据IDL协议，编码及解码参数和结果
- client communication module：客户方的通信模块，负责底层通信协议
- server communication module：服务器的通信模块
- server dispatcher：根据调用的过程决定去向哪一个stub
- server stub：编码、解码、定位到主程序
- server procedure*：服务的具体实现，提供结构化的格式

## 4.4 RMI

### 4.4.1 RMI设计问题

- 分布式对象：
  - 一些远程对象可以接受远程的调用，这些远程对象实现了一个远程接口，该接口的方法可以被远程调用。
  - 每个远程对象都会有一个远程对象引用，注意，这和本地的对象引用不是一个概念，而是一种扩展，在整个分布式系统中，这个远程对象引用可以唯一表示某主机，某进程中的某对象。
  - 本地的对象A如果拥有一个远程对象B的`远程对象引用`，那么就可以申请调用它的远程方法，甚至可以把`远程对象引用`当做**<u>参数和返回值</u>**，这一点RMI突破了RPC的局限性。
  - 远程接口有多种实现方法，比如Java库的`JAVA RMI`，比如跨语言的`CORBA`。当使用`CORBA`实现远程接口的时候，双方的语言都可以不相同，因为可以利用不同语言的封装解封装方式不同来屏蔽语言异构性。
  - 额外提一点，A进程中远程对象的远程接口中的方法中，可以创建一个新的远程对象，这个远程对象的生命周期和A进程的生命周期相同。

### 4.4.2 RMI实现

#### 底层通信

- 通信模块：架在某种请求-应答协议之上，服务器收到之后把`远程对象引用`这一标识符，化为本地引用，选相应的`dispatcher`发过去。

#### 数据支持：换用本地远程标识符

- 远程引用模块：实际上是一个数据库支持
  - 维护远程对象表：
    - 本地对象引用和`远程对象引用`之间的对应关系
    - 每个本地代理，即拥有的`远程对象引用`
  - `远程对象引用`到了，但是没有本地的对应，那就会创建一个本地代理（这种情况只会发生在客户端）
- 绑定程序：这个程序维护一个表：文本名字到`远程对象引用`的映射
  - 服务器用来注册远程对象
  - 客户端用来查`远程对象引用`
- 定位服务：有时候`远程对象引用`的表示法不能确切的标识一个对象位置，因为对象可能在不同进程间迁移。所以诞生了定位服务。在每一台主机上放一个小缓存，记录上次的远程对象地址，找不到了就广播来找。

#### 服务实体：真正实现代码

- 伺服器：服务器端真正执行任务的一个类的实例。
  - 伺服器一般是服务器初始化的时候造一个，之后根据用户需求创建。
  - 工厂方法：问题是用户调用的公有接口，不能包括构造函数，所以需要一个函数来创建新伺服器，这个方法就称作为工厂方法
- 服务器为每个请求单开一个线程
- 激活与持久存储：一个服务对象可能需要存储当前状态，但是又不一直用，所以给它状态存一下，压到磁盘里，称为被动对象。再次使用重新按状态激活即可。
  - 如果对象需要一直处于激活状态，那就要持久存储，就把对象扔到磁盘里。对用户要透明，用到的时候再激活回来，看起来像一直在内存里一样。

#### 中间件：屏蔽远程方法调用

- 代理：在本地，为每个`远程对象引用`开一个代理，实现这个远程对象的远程接口，实现方法：**整合请求信息并编码，发到通信模块，收到服务端结果之后，返回答案**
- 骨架：在服务器，为每个支持远程访问的类实现一个骨架，骨架实现这个类的远程接口，实现方法：**解码请求信息，调用伺服器方法，得到结果，编码返回**
- 分发器：在服务器，接收通信模块内容，选一个相应类的骨架送过去

中间件可以由IDL编译器自动实现

### 4.4.3 分布式无用单元收集

无用的对象何时回收有两种解决方案：

- 基于计数的（JAVA)：服务器为每个对象维护一个表，记录它服务的进程。每个客户用的时候，就会在创建代理时，注册一下，代理被回收，表就会被删除一项。删空了，就把服务器中的对象回收掉
- 基于租借的（JINI）：和客户协商一个租期，租期到了就收走，但是可以续约。JAVA就不会和客户协商，是内置的租期。

## 4.5 Java RMI

- 远程接口：通过扩展`Remote`接口来进行定义
- 本地对象作为参数进行RMI传递：不同于本地函数调用，传递的方式，是值传递，并且对象必须是可序列化的，即实现了`Serializable接口`，可以在消息中可以打平成字节流进行传递。
- 远程对象作为参数进行RMI传递：按引用传递。
- 简单类型作为参数进行RMI传递：值传递，简单类型可序列化。
- 类的下载：
  - 服务器接到了客户端的本地对象，会下载类的代码
  - 客户端接到了`远程对象引用`，会自动创建代理类。
- `RMIregistry`：服务器绑定程序，用Naming类就可以了
- 客户端和服务器端都要先创建一个安全性管理者
- 服务器端程序：
  - 远程接口有一个伺服器的实现
  - 创建一个伺服器，注册进绑定程序里
- 客户端程序
  - 用Naming类绑定程序查找接口对应的名字
  - 像本地方法一样用就可以了

- 回调：避免客户向服务器去轮询最新状态，服务器更新了状态之后，主动通知客户
  - 客户创建一个用于通知的远程对象callback
  - 客户通过服务器的远程接口，把callback的远程对象引用传给服务器
  - 服务器把所有客户的callback维护在一张表里，在事件发生时利用callback的`远程对象引用`执行RMI，传递最新信息
- JavaRMI中的反射：客户端代理把参数编码，和调用的接口方法，一起放进一个`Method`类的实例中，服务器dispatcher解码的时候，可以直接知道是哪一个对象的方法，直接去调用相应的伺服器，绕过了骨架