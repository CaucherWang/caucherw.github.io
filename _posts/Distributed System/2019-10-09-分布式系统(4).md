---
layout: post
title: RPC & RMI
categories: 分布式系统
description: 远程过程调用，远程方法调用，以及基本的请求应答协议
keywords: 分布式系统, RPC, RMI, RR protocal
---

# 4.远程调用

## 4.2 请求应答协议

描述了一个基于消息传递的范型，支持在客户/服务器计算中遇到的消息双向传输

一个弱于TCP，强于UDP的应用层通信协议。

- C/S模式，建立在UDP数据包的基础上

- 同步通信模式：发送方阻塞，直到收到服务方确认（异步通信也是可选的）
  
- 三个通信原语
  - doOperation
  - getRequest
  - sendReply
  
- 消息基本结构：外壳的作用就是因为存在故障问题，丢包，失序等
  - messageType：request or reply
  - requestId：主要为了故障处理而生，一个整数序列+发送者套接字地址
  - remoteReference:远程那个函数
  - operationId: 具体操作
  - 参数列表：字节流
  
- 超时：doOperation，超时就重发，此时消息ID就有用了，可以避免重复

- 面对重复请求：

  - 幂等操作：再次执行并传输结果
  - 非幂等操作：使用历史
  
- 历史：包含最近一次已发送消息记录的结构，这样重传就不需要重复计算，只需要再重传reply
  
  - 只需最近一次是因为同步协议，客户发出k+1个请求意味着第k个请求已经收到
  
  - 当然历史太大的时候，计算和存储的开销都会变大
  
- 交互协议的类型
  - 请求：UDP 客户端向服务器端发送一个单独的请求消息，这个协议可以用在不需要从远程操作返回值或客户端不需要得到远程操作执行确认的情况中。在发送请求后，客户端可以立即继续执行，而无须等待应答消息。
  - 请求-应答：不要求特殊的确认消息，服务器的应答消息可以看成客户端请求的确认。随后客户端的调用，可以视为服务器应答消息的确认。因UDP包丢失而引起通信故障可以通过带有重新过滤的请求传输和重新传输进行屏蔽。
  - 请求-应答-确认应答（类似TCP三次握手协议，更好的处理history）： 确认应答消息中包含了来自于应答消息的requestID。服务器可以利用这个ID来从历史中删除相应的条目。累积确认。尽管该交互过程涉及附加的消息，也无须阻塞客户端进程，因为该确认可能在向客户端发送应答之后才传输的。
  
- TCP流的使用（通选）
  - UDP数据包有长度限制，不利于RPC或RMI的透明化
  - 避免实现多包协议，不想让数据拆分成包，以传输任意长度的参数或结果，TCP是数据流
  - 可靠是优良的性质，使得通信简化，很多机制可以缺省
  
- 也可以基于UDP进行改良，如果不需要TCP所提供的所有服务的话

- 例子：HTTP：请求-应答协议
  - 内容协商：Client request里面包含一些它们可以接受的数据信息
  - 认证：质询
  - 持久连接
  - HTTP方法：
    - put,delete是幂等操作，但是post操作就未必

## 4.3 RPC

### 4.3.1 RPC 接口编程

#### 接口编程

- 分布式系统的接口
  
  - 在分布式程序中，模块能够运行在不同的进程中；在客户/服务器模型中，每个服务器提供一个客户端可用的方法集合
  
  - 运行在不同的进程里，和传统OS不同，传统OS有进程地址封锁，不同进程访问不到
  - 传递消息不能用引用参数，只能用值参数，然后将参数序列化
  
- 接口定义语言IDL：为多语言的应用RPC提供了统一的接口定义
  - Sun XDR、CORBA IDL、WSDL

#### RPC调用语义

- 重发、滤重、重传结果 or 重新执行过程 

- 或许调用语义：R，远程方法可能执行一次，也可能根本没执行，客户什么也不知道。除了重复以外，所有故障都可能出现。

- 至少一次调用语义：Client收到结果或异常。如果收到结果，那么该方法至少被调用一次了。不会丢包，但是会有重复。也不滤重，重新执行并且传结果。【幂等操作】

- 至多一次：Client收到结果或异常，如果收到结果，方法执行且只执行一次。重传但不重新执行，只发回复。

#### 透明性：

远程过程调用与本地过程调用尽可能相似

本地过程和远程过程的差异应该体现在接口上，使得本地过程调用和远程过程调用的语法上没有差别

### 4.3.2 RPC的实现

RPC在客户端留下了接口方法的**存根过程**，这个stub包含了对参数和返回值的编解码能力，可以把请求包装成一个消息，发送给通信模块进行传递；

对于服务端，从通信模块中得到的消息，由**分发器**辨识方法ID交给相应的**服务端存根过程**，服务端stub进行解码并在本地交给具体的实现方法进行具体实现，再发回服务端stub进行编码送回。

奇妙的是，两边的stub和服务端的dispatcher竟然可以从接口编译器根据接口的定义自动生成。

<img src="2019-10-09-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(4).assets/image-20191224120259495.png" alt="image-20191224120259495" style="zoom:67%;" />

  - 以SUN RPC为例，用户想要调用远程过程，有以下步骤

    - 创建一个句柄，指明服务器名字，程序标识符及版本
- 根据XDR接口（C语言），构造结构化参数及返回值
    - 直接调用远程过程，第二个参数为客户端句柄
  - 服务端的过程几乎和C语言无差异，只是要遵守一些函数命名、返回值、参数的规范协议而已
- 剩下的通信过程等底层过程，全部由IDL的编译器来自动生成，对高层程序员完全屏蔽掉

- client program*：用户的app，正如上面所展示的，要求调用远程过程，并提供结构化参数
- client stub：根据IDL协议，编码及解码参数和结果
- client communication module：客户方的通信模块，负责底层通信协议
- server communication module：服务器的通信模块
- server dispatcher：根据调用的过程决定去向哪一个stub
- server stub：编码、解码、定位到主程序
- server procedure*：服务的具体实现，提供结构化的格式

## 4.4 RMI

在RMI中，客户调用一个对象方法的请求以消息的形式传送到管理该对象的服务器，通过在服务器端执行对象的方法来完成该调用，并将处理的结果通过另一个消息返回给客户。

### 4.4.1 RMI设计问题

- 分布式对象：
  - 对象的状态由它的实例变量组成。在基于对象的范型中，程序的状态被划分为几个单独的部分，每个部分都与一个对象关联。因为基于对象的程序从逻辑上划分的，所以在分布式系统中可以很自然地将对象物理地分布在不同的进程或计算机中
  - **每个进程包含若干对象，其中有些对象既可以接收远程调用，又可以接收本地调用，而其他对象只能接收本地调用**
  - 一些远程对象可以接受远程的调用，这些远程对象实现了一个远程接口，该接口的方法可以被远程调用。
  - 每个远程对象都会有一个远程对象引用，注意，这和本地的对象引用不是一个概念，而是一种扩展，在整个分布式系统中，这个远程对象引用可以唯一表示某主机，某进程中的某对象。
  - 本地的对象A如果拥有一个远程对象B的`远程对象引用`，那么就可以申请调用它的远程方法，甚至可以把`远程对象引用`当做**<u>参数和返回值</u>**，这一点RMI突破了RPC的局限性。
  - 远程接口有多种实现方法，比如Java库的`JAVA RMI`，比如跨语言的`CORBA`。当使用`CORBA`实现远程接口的时候，双方的语言都可以不相同，因为可以利用不同语言的封装解封装方式不同来屏蔽语言异构性。
  - 额外提一点，A进程中远程对象引用的远程接口中的方法中，可以创建一个新的远程对象，这个远程对象的生命周期和A进程的生命周期相同。

### 4.4.2 RMI实现



<img src="2019-10-09-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(4).assets/image-20191224140208753.png" alt="image-20191224140208753" style="zoom:70%;" />

#### 底层通信

- 通信模块：架在某种请求-应答协议之上，服务器收到之后把`远程对象引用`这一标识符，利用<u>远程引用模块</u>化为本地引用，选相应的`dispatcher`发过去。

  <img src="2019-10-09-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(4).assets/image-20191224140113153.png" alt="image-20191224140113153" style="zoom:50%;" />

#### 远程引用模块

- 远程引用模块负责在本地对象引用和远程对象引用之间进行翻译，并负责创建远程对象引用

- 每个进程中的远程引用模块都有一个**远程对象表**，该表记录着该进程的本地对象引用和远程对象引用（整个系统范围内）的对应关系，包括：

  - 该进程拥有的所有远程对象

  - 每个本地代理（不在本地实现代码的，就在本地伪装一个接口，称为一个代理），即拥有的`远程对象引用`

  动作包括：

  - 当远程对象第一次作为参数或结果传递时，远程引用模块创建一个远程对象引用，并把它添加表中
  - 当远程对象引用随代理或应答消息到达时，远程引用模块要提供对应的本地对象引用，它可能指向一个代理，也可能指向一个远程对象。若远程对象不在表中，则创建一个新的代理，并将它添加到表中

- 绑定程序：这个程序维护一个表：文本名字到`远程对象引用`的映射
  - 服务器用来注册远程对象
  - 客户端用来查`远程对象引用`
- 定位服务：有时候`远程对象引用`的表示法不能确切的标识一个对象位置，因为对象可能在不同进程间迁移。所以诞生了定位服务。在每一台主机上放一个小缓存，记录上次的远程对象地址，找不到了就广播来找。

#### 服务实体：真正实现代码

- 伺服器：提供远程对象主体的类的实例。（服务器端真正执行任务的一个类的实例）
  - 伺服器一般是服务器初始化的时候造一个，之后根据用户需求创建。
  - 工厂方法：问题是用户调用的公有接口，不能包括构造函数，所以需要一个函数来创建新伺服器，这个方法就称作为工厂方法
- 服务器为每个请求单开一个线程
- 激活与持久存储：一个服务对象可能需要存储当前状态，但是又不一直用，所以给它状态存一下，压到磁盘里，称为被动对象。再次使用重新按状态激活即可。
  - 持久对象：在进程两次激活之间仍然保证存活的对象称为
  - 如果对象需要一直处于激活状态，那就要持久存储，就把对象扔到磁盘里。对用户要透明，用到的时候再激活回来，看起来像一直在内存里一样。

#### RMI软件：屏蔽远程方法调用

- 代理：在本地，为每个`远程对象引用`开一个代理，实现这个远程对象的远程接口，实现方法：**整合请求信息并编码，发到通信模块，收到服务端结果之后，解码返回答案**
- 骨架：在服务器，为每个支持远程访问的类实现一个骨架，骨架实现这个类的远程接口，实现方法：**解码请求信息，调用伺服器方法，得到结果，编码返回**
- 分发器：在服务器，接收通信模块内容，选一个相应类的骨架送过去

中间件可以由IDL编译器自动实现

- 动态调用：可替换代理的选择

  - 上面提到的创建方法是静态的，客户应用程序可以通过动态调用获得远程调用的一般性表示

  - 如果应用程序中的某些远程对象的接口不能在设计时确定，那么动态调用接口就会非常有用

- 动态骨架

  服务器有时需要驻留那些接口在编译时尚不能确定的远程对象，使用动态骨架可以解决这个问题

  利用一个普通的分发器，将类动态地下载到服务器

### 4.4.3 分布式无用单元收集

无用的对象何时回收有两种解决方案：

- 基于计数的（JAVA)：服务器为每个对象维护一个表，记录它服务的进程。每个客户用的时候，就会在创建代理时，注册一下，代理被回收，表就会被删除一项。删空了，就把服务器中的对象回收掉
- 基于租借的（JINI）：和客户协商一个租期，租期到了就收走，但是可以续约。JAVA就不会和客户协商，是内置的租期。

## 4.5 Java RMI

- 远程接口：通过扩展`Remote`接口来进行定义
- 本地对象作为参数进行RMI传递：不同于本地函数调用，传递的方式，是值传递，并且对象必须是可序列化的，即实现了`Serializable接口`，可以在消息中可以打平成字节流进行传递。
- 远程对象作为参数进行RMI传递：按引用传递。
- 简单类型作为参数进行RMI传递：值传递，简单类型可序列化。
- 类的下载：
  - 服务器接到了客户端的本地对象，会下载类的代码
  - 客户端接到了`远程对象引用`，会自动创建代理类。
- `RMIregistry`：服务器绑定程序，用Naming类就可以了
- 客户端和服务器端都要先创建一个安全性管理者
- 服务器端程序：
  - 远程接口有一个伺服器的实现
  - 创建一个伺服器，注册进绑定程序里
- 客户端程序
  - 用Naming类绑定程序查找接口对应的名字
  - 像本地方法一样用就可以了

- 回调：避免客户向服务器去轮询最新状态，服务器更新了状态之后，主动通知客户
  - 客户创建一个用于通知的远程对象callback
  - 客户通过服务器的远程接口，把callback的远程对象引用传给服务器
  - 服务器把所有客户的callback维护在一张表里，在事件发生时利用callback的`远程对象引用`执行RMI，传递最新信息
- JavaRMI中的反射：客户端代理把参数编码，和调用的接口方法，一起放进一个`Method`类的实例中，服务器dispatcher解码的时候，可以直接知道是哪一个对象的方法，直接去调用相应的伺服器，绕过了骨架