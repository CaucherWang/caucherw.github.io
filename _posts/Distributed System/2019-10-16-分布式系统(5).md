---
layout: post
title: 间接通信的实现原理
categories: Distributed System
description: 架在C-V模型之上的间接通信，分布式系统第六章内容
keywords: 分布式系统，组通信，发布-订阅系统，消息队列，共享内存，元组空间通信
---

# 5.间接通信

## 5.1 简介

存在中介的通信，可以不用C,S同时出现进行通信

- 时间解耦：发送者和接收者（们）可以有独立的生命周期，发送者和接收者（们）不需要同时存在才能通信，在易变的环境下，发送者和接收者可以随时进入和离开

- 空间解耦：发送者不知道也不需要知道接收者（们）的身份，反之亦然；参与者可以被替换、更新、复制或迁移

- IP组播：时间不解耦合，必须有人一直监听，但空间上解掉了

- 缺点：
  - 增加了中介层的开销
  - 难于精准管理（debug过程繁杂，设计中介层）

- 举例：

  <img src="2019-10-16-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(5).assets/image-20191224152114855.png" alt="image-20191224152114855" style="zoom:67%;" />

- 时间解耦合与异步通信的关系：
  - 异步通信时即使不在同一时间通信，但一定是存在的
  - 时间解耦合，C,S生命周期是独立的，C甚至可以不存在

## 5.2 组通信

 **组通信**（group communication）提供一种服务，在这种服务中，消息首先被发送到组中，然后该消息被传送到组中的所有成员。

组通信是对组播通信的抽象，可以通过IP组播实现或等价的覆盖网实现

- 组成员管理机制
- 故障检测机制
- 提供可靠性和保序

组通信，其实底层就是IP组播（路由器级别）在提供支持，从资源上讲，节省了带宽，降低了总时延，因为消息副本是在局域网位置被拷贝副本转发的。

### 5.2.1 编程模型

- 传递保证：
  - 要么全收到，要么全收不到
  - 组内收到的相对顺序

 组通信的重要特征是一个进程事项只发起一个组播操作，它就可以将消息发送到一组进程中的每一个，而不是发起多个发送操作到每个进程

- 进程组和对象组：
  - 进程组：把消息发布到进程为终点（JGroups工具箱）。层次较低，类似套接字层次，消息通常是非结构化的字节序列
  - 对象组：消息的终点是同一类的一组实例，对象并发执行操作，返回结果。层次更高。
- 其它组通信服务类别：
  - 封闭组和开放组：取决于组外进程能否发消息到组内
  - 重叠组和非重叠组：取决于一个进程能否加入多个组

### 5.2.2 实现问题

- 可靠性：
  - 完整性：无差错，无冗余
  - 有效性：无丢失
  - 协定：要么全收到，要么全不收到

- 排序：
  
  - FIFO序：从每个发送者进程来看，是有序的；但是从每个接收者角度来看，针对某个发送者是有序的，不通发送者之间，是无序的
  - 全序：所有接收者收到的消息完全一致
  - 因果序：考虑了逻辑关系
  
- 组成员管理：组通信视图**同步**，管理仍很困难

  - 基本服务：增/删组，组中增/删成员
  - 故障检测：检测器标记故障成员，剔除出组
  - 组地址扩展：发送者只需知道组标记，服务将消息分发到各个成员
  - 组成员改变通知：组成员发生改变时，通知全组
  

### 5.2.3 JGroups工具箱

- Java的可靠组通信工具箱

- 渠道：一个组的句柄，一个进程通过一个渠道对象和一个组相连接。


- 构造块：在渠道上方提供一个更高级的服务。其实是可有可无的。
  - MessageDispatcher：提供castMessage方法发消息到组中，保持阻塞直到收到一定数量的应答。
  - RpcDispatcher：调用这个组相关的所有对象的某个方法

- 协议栈：此协议栈不等同于OSI七层协议的协议栈，是在IP层之上适用于组通信的协议栈。

  - UDP：运输层，但不是UDP协议，是用IP组播实现，然后用了UDP数据报进行点对点传输
- FRAG：消息编码
  - MERGE
  - GMS：组成员协议，维护组成员之间的一致视图
  - CASUAL：实现因果序

## 5.3 发布-订阅系统

- 发布者：发布**<u>结构化</u>**的事件到事件服务
- 订阅者：通过订阅，表达对特定事件感兴趣
- 发布订阅系统：把订阅与发布的事件相匹配，保证事件被正确的传递。一对多的通信模型。
- 主要特征：
  - 异构性：由于通信是基于事件通知的，其实并没有严格的平台要求，任何不在系统设计范围内的单元，也可以加入系统。
  - 异步性：时间上的解耦，基于事件的空间解耦。
  - 传递保证：基于应用需求，可以用IP组播

### 5.3.1 编程模型

- 发布-订阅系统有一个操作集
  - 订阅者：订阅(filter）即为一种对发布者提供的不同patterns的选取，解订阅filter
  - 发布者：发布一个事件，或者广告（定义、更新）一个pattern
  - 发布订阅系统，将filter与pattern做匹配，把事件notify给订阅者
- filter模型：
  - 基于渠道：发布者给出渠道，事件扔到渠道里，订阅者从渠道里取事件
  - 基于主题：每个事件通知标记为若干主题，事件被扔到相应的若干主题里，订阅者从感兴趣的主题取事件。主题还可以进行层次化的设计。
  - 基于内容：订阅也可以是一个复杂的查询
  - 基于类型：根据事件类型和子类型，定义订阅模式。

### 5.3.2 实现问题

为了避免性能瓶颈和单点故障，分布式实现是必须的。P2P和C-S模型都在考虑范围内。也就是说，发布订阅中心系统是一个代理网络。

- 核心：事件路由层，保证事件通知可以路由到订阅者
- 基础设施：覆盖网络 or P2P

- 路由层技术：
  - 泛洪：两种方案，可以通过在代理网络中把事件推向所有邻居来发布
    - 直接向所有结点发送事件通知，在订阅者端执行事件匹配
    - 把订阅推向所有的发布者，匹配后直接点对点发布
    
  - 过滤：过滤的核心思想是把match任务放到代理网络当中，而不是把match推给订阅方或者发布者。对于每个代理网络中的节点必须存有以下信息：
  
    - 邻居列表：代理网络中的所有邻居
    - 订阅列表：直接相连负责的订阅者列表
    - 路由表：维护邻居中可以通向订阅路径的信息。
  
    算法如下：
  
    - 收到一个事件时：
    1. 先匹配自己的订阅列表，匹配成功的直接发送出去
      2. 然后查自己的路由表，找到存有此信息的邻居，把消息传给这些邻居
    - 收到一个订阅时：
      - 如果是一个订阅者发过来的：那就要存进订阅列表里；
      - 如果是邻居节点发过来的：那就要存进路由表里；
      - 无论如何，都要发给所有的邻居，当然除了发过来的那个邻居
    
  - 广告：在有广告的系统中，通过与订阅传播类似的方式，向订阅者传播广告，这样流量负担可以减少。
  
  - 汇聚：每个代理节点负责一些事件，及和这些事件相关的订阅节点。这个代理节点维护一个订阅列表，将成功匹配的事件转发到相应的订阅节点集中。一般来说
  
    - 算法如下：
  
      - 从某一节点得到要发布的事件之后，EN函数找到负责这个事件的所有节点列表中，如果自己在这个列表中，就match这个事件和自己的订阅列表并转发到订阅者节点。然后将这个事件发到其它负责改事件的节点中去。
  - 从某一节点得到订阅信息后，用SN函数找到负责这个订阅的所有节点列表，如果自己在，就把它加在订阅列表里，否则就发到其它负责这个订阅的节点上。
      
    - 对于匹配的事件e和订阅s，EN(e)和SN(s)必须有交集，就是说必须有一结点同时负责这个订阅和这个事件。这是因为一个订阅肯定包含一些事件空间。

## 5.4 消息队列

一种间接的点对点通信，可以实现时间与空间的解耦。消息队列也称为面向消息的中间件。

### 5.4.1 编程模型

接受方式：

- 阻塞接受
- 非阻塞接受（轮询）
- 通知

消息的组成

- 目的地
- meta data：中间件来生成处理这个信息的meta data
- 消息体：封锁，需要被编码

消息队列特性：

- 持久化：消息存到磁盘里的，直到被消费
- 可靠性：保证了可靠性传输
- 消息可以转换：消息队列中的消息代理可以对数据格式进行转换，比如大小端，或者不同的数据外部表示；消息队列还可以实现事务性或者安全性。

### 5.4.2 实现问题：研究WebSphere MQ

- 队列管理器：存储并管理队列，应用通过消息队列接口执行操作。
- 客户渠道：客户与队列管理器的通信方式，采用了RPC同步传送。
- 消息渠道：两个队列管理器之间是单工的信道，异步传送。由两端的消息渠道代理维护。
- 多个队列管理器之间可以构成一个拓扑，以实现最佳通信
- 集线器和辐条拓扑结构：辐条负责和应用通过客户渠道相连，集线器负责和辐条以及服务相连，同时实现了大部分的队列管理器的额外功能。当然，辐条也是队列管理器。集线器集群工作，辐条分布下去。
  - 性能瓶颈在于集线器。

### 5.4.3 实例研究：Java消息服务

一个规约，并非一个具体实现。

一个连接有两种不同类型的连接工厂

- 消息队列的
- 主题的

然后建立相应类型的连接，每个连接可以产生多个会话，每个会话可以有发布者，或者有订阅者，用以传递消息。

## 5.5 共享内存

### 5.5.1 分布式共享内存

时间空间解耦合。将文件映射到各个地址空间。

### 5.5.2元组空间通信

元组空间就像是共享内存一样。所以一样有时间空间解耦合。但是数据是半结构化的，元组没有地址，访问通过内容上的模式匹配。

#### 5.5.2.1 编程模型

- 元组：包含多个数据域，类似一个匿名结构体

- 操作集：

  - write：写操作
  - read：读操作，需要提供一个模式匹配，获得一个匹配的元组
  - take：读并删除操作，也需要提供一个模式匹配，获得一个匹配的元组

  注意没有update操作，update必须通过take+write来实现

#### 5.5.2.2 实现问题

分布式实现有几种：

- 复制
- 散列
- P2P

#### 5.5.5.3 实例研究：JavaSpaces

Sun开发的空间通信工具，提供了规约，由具体开发者实现

这里并非元组空间，而是对象空间，Java对象被放在一个JavaSpace里。这样的Java对象称之为一个entry，因为它实现了entry的接口。

- 生产者：

  - 找到空间，创建一个新的entry，并写进去

- 消费者

  - 找到空间，给出一个template entry，读一个出来

- entry定义：和正常类无异，只是实现了一个entry接口而已


## 总结

<img src="2019-10-16-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F(5).assets/image-20191224203337267.png" alt="image-20191224203337267" style="zoom:77%;" />

