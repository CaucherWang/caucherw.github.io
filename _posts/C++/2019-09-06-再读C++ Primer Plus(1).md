---
layout: post
title: 再读C++ Primer Plus(1)
categories: C++
description: 时隔初读一年，重新读这本经典教材
keywords: C++
---

## 概念摘要

### 基础知识

#### 1. 常量指针与指针常量

- 常量指针是说对于该指针来说，指针指向的数据是一个常量（实际上未必），即不可通过指针来修改指针所指向的数据。

  ```C
  int n;
  const int *p=&n;
  *p=1; // An error
  ```

- 指针常量是说指针本身的值是一个常量，它不能更改内存地址，即不能更改指针的指向。至于指向的东西，没有什么限制。

  ```C
  int a=1,b=2;
  int * const p=&a;
  p=&b; //An error
  ```

#### 2. 内联函数

- 内联函数是说要在编译过程中，直接把函数的代码copy到相应的调用位置当中去，而不是用重定位的调用过程。

- 这实际上是一种用空间换时间的策略，代码copy意味着代码本身占用多余的内存，减少了调用过程的代码，可以提高运行速度。

- 可以看出，当代码短小精悍，调用频繁时，用内联更为合适。

  ```C
  inline max(int a, int b); //后面接声明 or 实现都是可以的
  ```

#### 3. 右值与左值

- 左值：可用地址访问到的值，一般变量都是可以的
- 右值：常量，表达式

#### 4.引用

- 对于一个引用变量，它和引用指向的对象在同样的地址上，因此我们称之为变量的“别名”。

- 和指针有很大区别，多个指针变量指向同一个对象，这么多个指针变量各有不同的地址，且与变量的地址不同。但是多个引用变量引用同一个对象，他们的地址就是这个对象的地址，他们之后都代表同一个意思。

- 引用变量必须初始化，初始化之后就只能是这一个位置，因为任何对它的赋值，相当于把值mov到它所在的内存空间里，跟正常赋值没区别。所以引用变量是绝对“忠诚”的。

- 引用变量可以用作形参，这与传统的值传递和指针传递都有区别。

  - 值传递，拷贝值的副本，或内存用户栈，或寄存器，进行传递
  - 指针传递，在内存用户栈，开辟一个指针的副本，大大缩减内存开销
  - 引用传递，让形参成为实参的一个引用变量，指向相同的内存位置，实际上传递了一个引用变量

- 引用也可以作为返回值，这种传递仍然效率极高，实际上就是返回return后面变量的别名，因此也要特别注意，**<u>千万不要让函数返回一个内存会被清除的引用变量</u>**

  一个有趣的现象是，因为按引用返回是返回一个引用变量，所以这个返回的变量可以做左值，为了避免这种情况的滥用，可以用const引用来返回值

  ```C
  swap(a,b)=c;
  
  int & swap(int &a, int &b);
  ```

  

- 一般来说，引用形参不接受一个表达式或者**<u>右值</u>**的，但是有一些例外，就是当形参的类型是常量引用时，在下面两种情况之一，会生成函数内的临时匿名变量，然后让形参指向它。

  - 实参类型正确，但不是**<u>左值</u>**
  - 实参类型不正确，但是可以转换为正确的类型

### 面向对象特性基础

#### 1. 运算符重载

- 标准类型是没办法运算符重载的
- 如果把运算符重载写进成员函数里，就意味着运算不满足交换律，第一个调用运算的必须是类的对象
- 运算符重载会有一些特别的限制

#### 2. 友元函数

- 友元函数写在类的接口里，但是并不是类的成员函数，不由类的对象调用，甚至说类的公有数据和常量，都要通过作用域解析运算符(::)来调用。有趣的是，虽然不是成员函数，但拥有类成员函数的权限。这对于重新调整运算顺序有很大的帮助

  ```c++
  friend Time operator *(double m, const Time &t);
  ```

#### 3. 面向对象中的类型转换

- 只有一个参数的构造函数可以被隐式转换，但是用explicit声明构造函数，可以禁止隐式转换

- 类甚至可以向基本类型转换，要设在类内置一个转换函数

  ```c++
  operator int ();
  ```

#### 4. 静态成员

- 静态成员由static声明一律存储在静态存储区，与类的对象无关，但是由类的对象共享

- 静态数据，一般用于对象计数，在类方法文件中进行初始化，（不能在声明时初始化）

  ```c++
  int ClassA::sta_data=0;
  ```

- 静态常量：在类内初始化

- 静态函数：因为不绑定对象，所以只能利用静态数据，一般用于返回静态数据

  ```c++
  int x= ClassA::return_Data();
  ```

  

### 继承

#### 1.公有继承

- 从语法上来看，基类与派生类有三点联系最为重要
  - 派生类对象可以使用基类的公有方法
  - 基类的指针、引用可以指向派生类对象
  - 可以利用派生类对象为基类对象初始化或复制

#### 2.继承多态

- 派生类想要重写基类的方法，直接重写就可以了，不过推荐使用虚方法(virtual)

  因为声明使用虚方法之后，编译器将使用动态联编，即在运行时确定调用具体哪一段代码。

  换句话说，静态联编，不用虚方法，指针/引用是什么类型，就调用什么类型的方法

  动态联编，虚方法，指针/引用指向的是什么类型，就用什么类型的方法

- ABC(抽象基类)：这种基类只是提供一个概念，并不能创建该类的对象。

  从语法上讲，抽象基类与普通基类区别仅在于是否有纯虚函数，纯虚函数基类不给出实现，只给出接口，由派生类给出实现。

#### 3.继承中的动态内存分配

- 基类中有指针类型数据，并且在构造函数中使用了new，那么基类必须提供深度复制，比如析构函数，复制构造函数，赋值运算符。派生类如果没有额外的指针类型数据，这些就无需重新定义
- 如果派生类自己有额外的指针类型数据，这些全都要重新定义一次