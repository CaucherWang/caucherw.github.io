---
layout: post
title: C++迭代器
categories: C++
description: C++迭代器
keywords: C++
---

# C++迭代器

## 1. Overview

​	一般来说，对于OOP编程，类的概念可以将程序的数据层面进行封装，而泛型编程关注算法层面的封装。泛型最简单的例子就是模板，模板的存在让开发者不必在意数据类型，实现了第一个层次的封装。而迭代器提供了进一步的封装，可以让算法独立于所使用的容器。开发者可以不考虑所使用的容器，以通用的形式实现算法。

## 2. 迭代器的类型与层次结构

​	迭代器类似于指针的功能，只不过专注于容器方面的操作。其中无论何种迭代器类型，通用的操作是，*，==，!=。这三种是必备的。各种迭代器类型又有各自的特征，这主要由于算法对迭代器的要求会不一样。

### 2.1 输入迭代器

​	这是一个<u>只读</u>的迭代器，只能读不能写，输入是针对程序来说的，是说把容器的内容输入给算法。由于需要遍历，必须提供++操作符。

​	这个输入迭代器同时面临着很多的麻烦，只能把输入迭代器当做一种单向的迭代器，只能从前向后，却不能从后向前迭代。而且算法每次迭代的顺序还不一定相同，而且即使是同一次迭代，它迭代过的值也未必还能迭代。

### 2.2 输出迭代器

​	指的是把算法的结果写进容器，支持++。这个迭代器恰恰相反，是只写的，不能读。同输入迭代器一样，它也是单通行的。

### 2.3 正向迭代器

​	也是只有++运算法，优点是每次迭代顺序一定，迭代过的值是可以访问的。可以读写，也可以只读

### 2.4 双向迭代器

 	双向迭代器同时支持++和--，是正向迭代器的扩展。

### 2.5 随机访问迭代器

​	在双向迭代器的基础上，增加了随机访问的能力。可以在一个迭代器的基础上加减一个常数，可以使用[]，可以让两个迭代器相减或者相比较，功能强大。

### 2.6 迭代器层次结构

​	可以看到迭代器的功能是有层次的，输入输出最弱，能适应的容器也最多，随机访问最强，能适应的容器也最少。实现算法尽可能找功能层次要求最低的，从而其可以适应更多的容器类型。

## 3. 迭代器的概念和常用迭代器

​	我们所阐述的迭代器，只是一种概念，细化为一系列的功能要求，并非是一个确切的类。一切能满足其要求的类实现都可以作为一种迭代器，比如最普通的指针，就是一种随机访问迭代器。

​	概念的层次结构有点像OOP的继承机制，我们通常称之为<u>改进</u>；某一个迭代器概念的一个具体实现称为一个模型，指针就是一个随机访问迭代器模型。

- 指针用于迭代器：

  ​	我们的STL算法的接口，即其参数，都是迭代器，既然指针可以作为迭代器，自然可以使用STL算法。比如普通的一个数组，就可以使用STL算法sort,形参就是前后指针。C++同时支持普通数组的超尾。

  ​	进一步，STL算法甚至可以用于我们的自定义类型，只要能提供一个随机访问迭代器模型。

- copy()算法

  ​	copy算法接受三个参数，前两个是输入迭代器，最后一个是输出迭代器。是以前两个输入迭代器为范围限制，将容器内容复制到输出迭代器中，并要求输出迭代器必须有空间存放其内容。

  ​	虽然只用到了输入输出迭代器，但是copy算法可以保证顺序。

- ostream_iterator和istream_iterator

  ​	这两个迭代器类型一个代表输出流，一个代表输入流。

  - ostream_iterator有两个模板参数，第一个代表输入迭代器的数据类型，第二个代表输出到输出流的数据类型。迭代器初始化有两个参数，一个代表输出流，比如count,fout；另一个代表输出分割符，比如",".

    ```c++
    ostream_iterator<int,char>out_char(cout,",");
    // out_char迭代器表示接受int型容器数据，并将其输出到cout，输出类型为char，每个数据之间以“，”分隔
    int a[]={1,2,3,4,5};
    copy(a+1,a+4,out_char);
    ```

  - istream_iterator也有两个模板参数，第一个代表想要读取的数据类型，第二个代表输入流使用的数据类型，构造函数有一个参数，代表输入流，比如cin；如使用默认构造函数，则代表文件尾or读取错误迭代器为终止.一个小技巧，Ctrl^Z可以在标准输入里模拟文件尾。

    ```C++
    istream_iterator<int,char>in_char(cin);
    istream_iterator<int,char>end_char();
    int a[5];
    copy(in_char,end_char,a);
    //从标准输入流读取一串字符，把每一个当做是一个int型数据，存入数组a
    ```

-  reverse_iterator，即反向迭代器。逆序遍历也是算法的常用操作，当然，对于双向迭代器及更高层级的，--操作就可以实现逆序了，但出于对算法的重用，仍然引入反向迭代器。

  ​	reverse_iterator将++操作重写为--操作。并设置了rbegin(),rend()方法来分别表示超尾和第一个元素。作为补偿，对发现迭代器解除引用，是先“++”，然后解除引用。这样避免引用超尾。

  ```c++
  int a[]={1,2,3,4,5};
  vector<int>va(a,a+5);
  copy(va.rbegin(),va.rend(),a);
  //这样就把a的元素逆序过来了
  ```


- back_insert_iterator，即后插迭代器。普通迭代器用于copy算法的一个弊端就是要预判内存，即使可以在运行中动态分配。插入式迭代器用于解决这个问题。后插迭代器用于那些具有push_back()方法的容器中，比如vector，之所以后插迭代器不用预先分配内存，源于push_back()方法是有权扩展容器的size的.

  迭代器类型有一个模板参数，为容器类型，用于选择容器方法；初始化需要具体的容器对象

  ```c++
  vector<int>va;
  back_insert_iterator<vector<int>>back_ins(va);
  int a[]={1,2,3,5};
  copy(a,a+4,back_ins);
  // 将数组a的值附加到va的尾部
  ```

- front_insert_iterator，即前插迭代器。与后插恰恰相反，前插迭代器需要一个允许前插的容器类型，比如queue。

- insert_iterator，即插入迭代器。与前两种不一样，插入迭代器对容器类型没有什么要求，其初始化函数有第二个参数，即插入位置，也是一个迭代器类型。

