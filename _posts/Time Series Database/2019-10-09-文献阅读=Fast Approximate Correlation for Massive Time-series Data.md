---
layout: post
title: 文献阅读：Fast Approximate Correlation for Massive Time-series Data Correlations  
categories: Times-Series-Database
description: 对于庞大时间序列快速找出估算相关系数矩阵
keywords: time series, relevant coefficient matrix, time optimization, query on-the-fly 
---

# Abstract

在数量极多的时间序列中计算两两关系。

提出基于DFT（离散傅里叶变换）和图分割的算法来降低端到端的两两关系查询的响应时间？

- 减少I/O代价：把大规模输入信号分割成小的批，一次内存缓存一批信号可以最大化数据重用和最小化磁盘IO
- 减少CPU代价：两个估算算法。
  - 第一个算法：相似信号对的近似相关系数
  - 第二个算法：找到所有有相似关系的信号对

主要是给出一个高效的近似算法。

# 1. Introduction

大量流式数据需要流式数据仓库系统SWS，SWS应有如下特性：

- 对长时间的数据归档存储
- 有效支持数据挖掘与统计分析
- 监控多个数据中心（DataGarage）

SWS的查询主要是专用类型查询语句，优化效率难点在于：

- 检索的数据量太大
- 对数据进行预处理，比如物化视图或者索引意义不大，因为都是**<u>运行中查询</u>**

之前的工作：

- 压缩数据
- 跑简单查询

考虑：给定n个等长信号序列，计算一个相似度矩阵C，C[i,j]，表示第i个序列和第j个序列之间的相似系数，这里用的Pearson相似系数

#### PROBLEM 1：给定一个相关系数下界T，n个信号序列之间的联系如果不小于T原样放上去，小于T，置0

PROBLEM1是基于人们更关心哪些序列相似，不关心哪些十分不相似的序列。

然后说数据集分割成batch然后缓存的问题，提到batch是精心创建的，在同一批里的信号对大多是相关的，在不同批里的多数不相关。

提出的算法可以组合使用：

1. 用第一个估算法找到找到满足自定义边界条件的序列对
2. 如果对数据感兴趣，可以进一步用第二个估算法把假阳性点剔除掉
3. 还有需要，那就用之前的精确算法

之后作者还扩展延伸了反相关和延迟相关的基本算法。

# 3. MOTIVATION（代价度量）

可以这样考虑代价，cache size可以容纳$\frac{n}{q}+1$个信号序列，一共n个信号序列需要两两计算相关系数，于是把这n个信号序列按顺序分成q个batches，进入循环

- 读进一个batch，这个batch内的序列先两两计算相关系数
- 在磁盘中剩余的没读进过内存的序列中每次读一个序列上来和内存中batch里的序列两两计算相关系数
- 读完了返回第一步继续循环，直到所有batch都读完

# 4. REDUCING I/O COSTS

减少IO有两种的办法：

1. 剪枝。如果算法能知道哪些序列对之间有联系，就只算这些序列对的相关系数，不管其它的了。
2. 智能缓存。手工把相关的序列对放到一个batch。

这也带来了两个问题：

1. 怎么知道哪些序列对有关？并且这个算法不能超过O(n$^2$)，也不可能低于O(n)
2. 找到了哪些序列是强相关的，怎么确定把序列读到内存的顺序？

## 4.1 找到相关联的序列对

用的是DFT。
$$
X_i=\frac{1}{m}\Sigma_{k=0}^{m-1}x_k*exp(\frac{-2\pi ik}{m}j)~~~~~i=0,1,2,…,m-1
$$
可以看到每一项DFT参数，都涉及一次完整的原序列遍历。

引理1：两个序列的相关系数可以用欧式距离来衡量：
$$
corr(\vec{x},\vec{y})=1-\frac{1}{2m}d^2(\vec{x_{nm}},\vec{y_{nm}})
$$
m是序列长度，x,y是两个序列，nm代表规范化过的序列

引理2：由引理1可得，两个序列距离大于$\sqrt{2m(1-T)}$,相关系数肯定不合格，不予考虑。序列的距离也可以从时域的距离转移到频域的距离，把正规化的x,y再用DFT变换一下，变换之后只需要计算前几项就可以判断出来，不过得到的是一个结果的超集，但是好在没有假阴性的结果。

<img src="C:\Users\64451\Pictures\md_images\1570711844503.png" alt="1570711844503" style="zoom:33%;" />

算法1：IO代价-O(n)

1. 每个序列都读上来1次，正规化，然后算这个正规化后的序列的DFT的前几项，然后留在内存里。
2. 所有序列读完之后，两两计算距离，满足条件的留下

算法得到的矩阵，称为剪枝矩阵$Pruning ~Matrix$

## 4.2 缓存策略

基本沿用第三节的缓存策略，不过肯定有改进，改进之处在于利用了4.1找到的剪枝矩阵：

1. 每次一批序列读到内存中，内部互相计算相关系数之后，每次从磁盘中读一个剩下的序列和内存中的序列计算系数；这里改进为：如果磁盘中剩下的某个序列和目前内存中的序列根本不相关，就不必读上来。
2. 仔细处理分批。注意到如果两个相似序列在不同的批中意味着一次额外的磁盘读取。如果我们能尽量把相关的序列放在一批里，就能有最小的磁盘开销。

第一个改进不难处理，但对于第二个改进涉及到具体如何分批，我们可以抽象成一个图论问题：

- 考虑一个无向图G，现要将其分割成若干子图，每个子图包含的节点数不能超过上限B，使得连接两个子图中点的边尽量少。

这是一个NPC问题，基于需要在线处理的角度来考虑，选择了一个最简单也是最快的现有算法：FM算法。FM算法是均匀二分算法，这里考虑多路递归FM算法，把子图的size降到B以内。

均匀二分图算法是个NPH算法，FM这里用了启发式算法，先随机找个解，然后不断优化。定义一个点的（负）收益是邻接点中在不同分割和在同一个分割的个数之差。每次迭代，对于图中点的收益降序排列，把一个点放到另外一个分割，让前k个点做这样的试探，保证前k个点的收益最大化。算法停止于无法再优化分割。可证明，迭代次数收敛于一个不大于10的数。

递归使用FM算法，产生$2\lceil n/B\rceil$个分割，这样的话很多分割其实size远小于B，作出适当合并，使得他们的size还是小于B。

# 5. 减少计算开销

现实世界对于计算相关系数矩阵这个问题有两个特征

- 计算允许一定范围内的误差
- 系数是多少一般不重要，找到所有满足关系边界的序列对往往更为重要。第4.节的方法中包含一些假阳性解。

## 5.1 近似边界关系矩阵

#### PROBLEM 2：给定一个相关系数下界T，n个信号序列之间的关系系数如果小于T，置0；否则，给出误差在$\epsilon$的关系系数

DFT还有一项性质很重要：

<img src="C:\Users\64451\Pictures\md_images\1570808336877.png" alt="1570808336877" style="zoom:50%;" />

这样就可以计算傅里叶变换的前k项来估量两个序列的近似相关系数，存在假阳性的可能。注意到每一个傅里叶参数都需要O(n)的计算代价，为了最小化这个代价，就需要找到最小的k。这个最小值对于不同数据集是不同的。

接下来探讨近似误差和k值之间的关系。

定义：一个信号的强度可以定义为其离原点的欧氏距离。前k项的也可以这样定义。

引理3：对正规化的信号进行过DFT的频域上的序列，强度是1.

<img src="C:\Users\64451\Pictures\md_images\1570809012924.png" alt="1570809012924" style="zoom:50%;" />

由此导出一个主定理：用这个定理就可以不断试探性的迭代递增k来找到最小的满足条件的k。

<img src="C:\Users\64451\Pictures\md_images\1570809466178.png" alt="1570809466178" style="zoom:67%;" />

另一方面，不断迭代k的同时，也可以直接算两个序列的距离，如果中途距离就超标了，直接就弃掉了。

## 5.2 边界布尔关系矩阵

在边界内的关系置1，否则置0.完全不涉及具体或估算的数值。

要想利用这个特性，需要考虑两个序列距离的上下界。

<img src="C:\Users\64451\Pictures\md_images\1570811567579.png" alt="1570811567579" style="zoom:50%;" />

<img src="C:\Users\64451\Pictures\md_images\1570811580666.png" alt="1570811580666" style="zoom:50%;" />

可以说，上下界距离越近，这个定理的应用效果就越好。如果不能用这个定理确定下来的序列对，就只能精确计算了。接下来探讨如何确定上下界，作者首先淘汰了DFT，理由不详述了。然后给出一个定理。

<img src="C:\Users\64451\Pictures\md_images\1570811974458.png" alt="1570811974458" style="zoom:50%;" />

这个第三方序列不能随机选，要么选和x,y都距离相近的，要么至少和一个相近，才能更有意义。接下来探讨如何选取这个第三方序列。

- 动态规划算法：这个算法计算每两个序列之间的距离的上下界。
  - 状态转移方程：<img src="C:\Users\64451\Pictures\md_images\1570812795255.png" alt="1570812795255" style="zoom:50%;" />

# 6. EXTENSIONS

## 6.1 负相关

<img src="C:\Users\64451\Pictures\md_images\1570813044266.png" alt="1570813044266" style="zoom:33%;" />

<img src="C:\Users\64451\Pictures\md_images\1570813064064.png" alt="1570813064064" style="zoom:33%;" />

通过简单符号变换就都可以扩展，复杂性不变。

## 6.2 延迟相关

<img src="C:\Users\64451\Pictures\md_images\1570813449758.png" alt="1570813449758" style="zoom:33%;" />

重定义相关系数之后，再定义一个最大延迟相关系数：所有可能的延迟中，最大的相关系数。接下来是探讨如何找到最大延迟。

主要用的是一个叫BRAID的方法在几何级数中探测，不过这个方法是在时域中找的，代价较高，作者把它改在频域上了。

<img src="C:\Users\64451\Pictures\md_images\1570813879660.png" alt="1570813879660" style="zoom:50%;" />

大概思想是一个序列算前缀，一个算后缀；所需的参数由之前算的序列的DFT前几项序列参数来决定，不足的直接补0。作者在实际中证明问题不大，不过也是一个理论上的疏漏。

只要找到了最大延迟，剩下的做一个移动就和之前一样了。



# 总结

这篇文章解决的是估算出一个相似系数矩阵的问题

给定n个序列，分两步解决问题，第一步给出一个剪枝矩阵，找到满足边界条件的序列对，但存在假阳性解；第二步给出一个近似矩阵，对于那些有关系的序列对，在$\epsilon$的范围内，给出一个近似值。或者给出一个精确的布尔矩阵。

## 第一步：剪枝矩阵

- 此时对于序列间可能的关系一无所知，所以把每个序列都从磁盘中读上来一次，正规化，DFT，保留前k项在内存中，然后进行两两比较，确定是否满足相关系数边界条件。磁盘复杂度O(n)，磁盘搜索B次，传输n次；计算复杂度O(kmn+n^2)
- 算法结束之后，给出一个剪枝矩阵，比布尔矩阵多一些假阳性解。
- 之后我们关心的，只有那些为‘1’的点，于是考虑给整个序列图分割，使得不同子图之间的联系是最少的，之后的算法，如果需要遍历所有序列，磁盘复杂度可以维持在搜索B+e次，传输n次，e是在不同子图之间相连的边。本文中用FM算法解决了图分割的问题。

## 第二步（1）：布尔矩阵

- 目的：对于剪枝矩阵中‘1’的解，排除那些假阳性解，给出精确的布尔矩阵。
- 方法：动态规划算法，对于那些在剪枝矩阵中‘1’的序列，初始算出对角线上的序列的准确距离，然后其他$\frac{(n-1)*(n-2)}{2}$个值由动态规划算法决定，最差情况下，两两序列之间的关系系数都是需要具体计算的，计算复杂度为O($\frac{n*(n-1)}{2}*m$)。最好情况下，只有对角线需要具体计算，计算复杂度为O($n*m+\frac{(n-1)(n-2)}{2}$)

## 第二步（2）：估算矩阵

- 目的：对于剪枝矩阵中‘1’的解，给出一个近似解。
- 方法：给定一个误差范围$\epsilon$，可以确定出最小的k，即算DFT参数的前几项，可以满足误差在一定范围内。然后通过前k项DFT参数距离，直接得到近似的相关系数。计算复杂度O($\frac{n*(n-1)}{2}*k$)。因为之前已经算过DFT参数了。如果有参数没算到k那么大，那么每个序列就需要再计算$\Delta k*m$次。

## 第三步：精确矩阵（有需要再进行计算）

