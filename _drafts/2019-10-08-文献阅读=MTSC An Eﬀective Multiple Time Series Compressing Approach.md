---
layout: post
title: 文献阅读：MTSC An Eﬀective Multiple Time Series Compressing Approach  
categories: Times-Series-Database
description: 通过挖掘列相关关系设计轻量辅助索引
keywords: index,column correlations,lightweight
---

# Abstract

文章的主要目的是解决多时间序列的存储压缩问题。

1. 提出了一个代表模型，用一个基序列和一个单值来代表其它序列
2. 提出了两个图论算法用于将时间序列聚簇，$MTSC_{mc}$有高压缩率，$MTSC_{star}$牺牲一些压缩率，达到高性能。

# 1. Introduction

- SBR

  最开始有一个叫SBR的机制，可以将相似的时间序列聚集成簇，在同一个簇内，用一个基础序列估算其它序列。局限有两个地方：

  1. 只能在运行算法之前，将相似的序列静态的绑在一起，这对于长时间序列来说不合适
  2. 误差范围是$L_2$而非$L_\infin$,这意味着单时间点的误差范围不可预测

- GAMPS

  误差范围可以控制在$L_\infin$，利用的是一个动态分组方案，在不同的time window里，将序列分组。在每一组需要一个共同的基序列，然后组内的每个序列用这个基序列和一个相关序列进行预测，然后再压缩基序列和相关序列，用APCA代表。遗憾的是，压缩质量不好。

- MTSC（本文）

  空间消耗极小，核心的是一个分组策略，这个策略能保证组数尽可能少，

# 2. Preliminaries

误差以所有序列中最大偏差那个计算

## 2.1 APCA简介

将一个时间序列划分成k段，每一段保留一个值，这个值和这个段的所有value的差在有限的范围内

# 3. 压缩模型和算法概览

## 3.1 表示法模型

#### 单视窗模型

一个多时间序列集S，可以被表示成一个三元组$\delta=(C,B,O)$

- C把S划分为多个序列簇
- B为每个序列簇找到一个基序列
- 某个簇中的任一序列可以表示为该簇的基序列加上一个偏移量，这就是说对每一个S中的序列，都有一个相对于其簇中基序列的偏移量，所以这个O的基数等于S的基数

------

到此为止，$\delta$可以单独表示一个S，现在的目标是尽可能减少S和B的基数（是同一个量，即划分成多少个序列簇）。

------

#### 多视窗模型

按照时间段再把时间分开，形成不同时间段的多序列集，$S^i_j$代表在第i个时间段，第j个序列。每个多序列集$S^i$可以被一个$\delta_i$唯一表示，那么我们的表示模型可以理解为
$$
\Delta=(\delta_1,\delta_2,…,\delta_m)
$$
注意：视窗长度，即时间段长度，是用户自定义的。

## 3.2 理论基础

#### 定义1：$\epsilon-similar$

- 两个序列是$\epsilon-similar$的，那他们对应项值的差最大不超过$\epsilon$

#### 引理1：

- 对于一个时间如果任意一个时间序列集，如果任意两个序列之间都是$2\epsilon-similar$的，那么这个时间序列集就有一个基序列B，和所有集合中的序列的最大误差是$\epsilon$

在图论算法中，将每个时间序列视为一个顶点，将两个序列之间的相似度视为边。

# 4. $MTSC_{mc}$算法

## 4.1 序列分组策略

### Mc-grouping

对于一个window里面的所有子序列，先都减去他们的平均值，这样让每个子序列在给定属性下的平均值是0。注意此时不同子序列减去的平均值肯定不一样，但是由于我们关注的是子序列的变化趋势是否相同，绝对值意义不大，所以把“偏移量”减去会方便计算。

每个点代表一个正规化后的子序列，边代表新子序列的‘距离’，即在这个window下的最大差值，只有距离小于$2\epsilon$的才能成为一条边。

在每个window都做好一幅图之后，可以用一个基于$maximum ~clique$的算法聚集序列。

#### 定义2：$maximum ~clique$

在一幅图里的最大完全子图。

找这个$maximum ~clique$是一个NP-Hard问题，没有精确算法，这里采用一个快速确定性算法。

先找到一个最大完全子图作为第一个cluster，然后删去这个cluster的所有点和边，在剩余的图中找下一个，直到没有边，剩下的点作为单点cluster.

#### Inc-grouping

主要是利用连续的window之间联系的相似性，先从上一个window继承它的cluster，然后再根据自己window的情况修改修改。

- 首先正规化，然后构图
- 之后对于上一个window的第一个cluster，继承它的所有点，它的边如果在本window有就画上。
- 如果做出来的cluster是个完全图，就直接变成这个window的cluster，如果不是完全图，就删去一些点让它是完全图。
  - 首选度数最小的点
  - 删点循环
  - 如果最后都变成一个个单点了，那也构成单独的cluster
- 对于上一个window的每一个cluster都执行此操作，最惨的就是都变成单点了，然后进行下一步。
- 下一步就是把单点试探着加入所有的cluster，能加就加，不能加就算了。

#### 一起使用

第一个window，肯定用mc-grouping；对于之后的window

- 用边的变化率来衡量它和第一个window的图有多大差别
- 如果差别未超过用户定义的上界，就用inc-grouping
- 否则用mc-grouping

