---
layout: post
title: 文献阅读：Designing Succinct Secondary Indexing Mechanism by Exploiting Column Correlations  
categories: Times-Series-Database
description: 通过挖掘列相关关系设计轻量辅助索引
keywords: index,column correlations,lightweight
---

# Designing Succinct Secondary Indexing Mechanism by Exploiting Column Correlations

## 摘要

## 1. 介绍

## 2. 背景

不同于之前的“强”函数依赖，现在分析的数据，大多有一种“弱”函数依赖；未必有完全的决定关系，但是大约会有一种关系。

一个三元组$(M,N,F_n)$，M，N分别代表两列（或者列的集合），$F_n$代表从M的值估计N的值的函数，这个函数不仅是传统意义上的函数，可以是任意可能的形式。

这样的数据特征已经被用来解决很多问题，数据压缩、查询语句的语法分析重构、数据库调优等等，这篇文章主要是说怎么用这个方法加速数据访问。

## 3. 概览

列数据的关联会导致索引结构的相似，文章发明了一个新的辅助索引机制，HERMIT，来利用这种相似性，减轻索引大小。

对于特定某一列M，为了索引它需要两个部分：

- M上的TRS树（对M与N之间的关系进行建模）
  - 利用了分层回归的方式对M->N的函数$F_n$进行分层拟合
  - 用一个树的结构对一系列回归函数进行索引，每个回归函数代表从M的取值范围到N的一个映射
- 与M相关的N列的一个已经存在的完整的索引

------

HERMIT对查询执行一个三阶段的算法：

1. TRS树搜索
   - 提供从目标列到宿主列的映射，通过这个映射，找到宿主列的值范围
2. 宿主索引搜索 
   - 宿主列是有完整索引的，有了范围，可以fetch出一些备选tuple
3. tuple确认
   - 对这些备选tuple目标值再次进行确认

主要用于内存关系型数据库，存储资源十分紧张的时候。

范围查询表现不错，点查询就很一般了。

## 4. TRS-TREE

分层回归方法，动态地，自适应地去拟合函数曲线

- 精确性：把复杂的曲线回归问题拆解成子问题，然后用线性回归的方法解决这些子问题
- 自适应性：基于列相关的复杂性构造树的内部结构
- 动态性：运行时可重构这棵树

### 4.1 内部结构

k叉树：从目标列M到宿主列N的映射

构造算法：递归地把M的取值范围拆为k等份，直到所有的(m,n)对中的m,都可以被包含在一个M的取值子范围内，在这个范围内,m->n，有一个线性的关系。

叶子结点存储具体映射，中间节点提供导航。

<img src="../images/2019-09-23-internal-structure.png" alt="2019-09-08-physical-view" style="zoom:38%;" />

#### 4.1.1 叶子节点

每一个叶子节点都是一个子范围，在这个子范围内m->n有一个确切的线性关系
$$
n=\beta m+\alpha±\epsilon\\
\beta=\frac{cov(M^r,N^r)}{var(M^r)}\\
\alpha=\overline{N^r}-\beta\overline{M^r}
$$
cov代表协方差（协方差描述两个随机变量的相关性，变化趋势同步为正，相反为负，不相关为0），var代表方差，上划线代表均值。置信区间$\epsilon$可以被用户定义的参量error_bound计算得到，4.5中说。

- 然而并不是所有的(m,n)对都满足计算出来的线性函数，这一类点对称为异常点，叶子节点为这些异常点维护了一个异常点缓存区，由一个哈希表来实现，从异常点m映射到主键或tuple位置

#### 4.1.2 内部节点

内部节点和叶子节点一样，同样代表一个范围，维护固定数目的指针。

#### 4.1.3 TRS-TREE构造方法

维护一个队列，队列每个元素是一个节点和该节点对应的暂时表，暂时表维护这个节点对应范围的表中元素，当然只投影到关联的列和主键列。

进入主循环：

- 从队列出队一个元素
- 计算这个元素的暂时表，包括$\alpha$、$\beta$、$\epsilon$，然后判断一下是不是映射的到位。
- 如果映射不到位，那就把这个节点分掉若干孩子节点，然后孩子节点进队

那如何判断映射不到位呢？就再用生成的线性函数扫一遍所有的节点对，不在映射范围内的，全部加入到异常点buffer里，如果这个buffer的size相对于这个节点所有的tuple的比例（outlier_ratio)到达一定值，就是不到位。

如果不到位的话，当前节点直接丢弃所有内容，然后按照固定的node_fanout均分值范围，产生孩子节点。

另外，树的最大深度可以设一个限值。

用户设置的参数对于线性函数的置信区间，异常点缓存区大小有直接影响，间接影响了索引性能。4.5中讨论了参数，附录D有优化策略。

- 复杂性分析：对于每一层的节点，Compute要遍历一整个表，Validate小于一整个表，最大深度固定，所以时间复杂性是$O(N)$

## 4.3 查询

层次性遍历这棵树，遇到中间节点且有intersect范围的就进入队列；遇到叶子节点，且有intersect的范围，就把相应的host column的值范围并进来；另外搞一个集合，把对应叶子节点outlier buffer中满足条件的tuple的地址或者主码添加进这个集合里。

==其实这里算法可以优化一下，因为是按顺序往下分的，所以找到上界停下来就可以了，没必要到队列全空==

## 4.4 维护

这个TRS-TREE，还能动态的支持增、删、改，还能在运行时调整结构。这和传统的基于机器学习的构建方法差别很大，ML-based方法需要长时间的训练阶段从随机乱建索引开始来重建索引。

- 插入：找到对应叶子节点，如果映射关系满足很好，那就只插进临时表就行了；满足的不好，就进outlier buffer;最怕的就是这个buffer满了，那就要单独调用重构程序了。

- 删除：也是找到对应叶子节点，直接删除就行了。不过删除次数太多，空间优化就需要重做

- 重构：

  有两种情况触发重构：

  - outlier buffer满：该节点再分一次若干孩子节点
  - 某一叶子节点中，删除的tuple占总tuple比例达到一定上限：查看邻居来确认是否要merge 

  后台开一个线程执行重构过程，通过一个简单的同步协议，查询/插入/删除受到的影响很小

  额外维护一个队列，插入或删除时碰到需要重构的节点扔到这个队列里；插入的话把需要split的节点扔到队列里，删除就把需要merge的父节点扔到队伍里；再把节点标记一下是要split还是要merge

## 4.5 参数

 node_fanout，max_height，outlier_ratio

error_bound：代表一个点查询得到的host column相应的值的个数。

设置这个参量，可以粗略估计点查询中错误的结果；再假设host column值是均匀分布的，就可以得到点查询中得到的相应值的个数，就是error_bound，从此跟$\epsilon$建立了联系。

- error_bound太大，返回的范围也大，给查询加负担
- error_bound太小，异常点就多了，树的深度也增加了

作者说实际上这个参量影响不大，因为范围查询通常在secondary key columns上，放大一点$\epsilon$导致的错误集跟大量的结果集想比不值一提。

# 5. HERMIT

## 5.1 Tuple Identifiers

- 逻辑指针，（主码），MySQL在用
- 物理指针，（BlockID+Offset），PostgreSQL在用

## 5.2 Lookup in Hermit

HRS-Tree查完之后，host column index查，merge identifier之后，主键查，主键查完之后fetch磁盘，同时进行validation

# 6. Discussion

- error_boud越低，查询性能越好；越高，空间越省，查询性能要下降。实际上只要error_bound别太大，对性能影响都不突出。